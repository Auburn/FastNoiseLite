###############################################################################
# PSFASTNOISELITE
#
# WRITTEN BY GREGORY F MARTIN <GREG@GREGFMARTIN.ORG>
#
# PSFASTNOISELITE IS A "POWERSHELL-NATIVE" PORT OF THE FAST NOISE LITE LIBRARY.
# WHILE FAST NOISE LITE OFFERS A C# DIALECT VARIANT, AND IT COULD BE IMPORTED
# INTO POWERSHELL AS-IS, IT'S NOT A "NATIVE" IMPLEMENTATION RESTRICTED TO
# POWERSHELL SPECIFIC CONSTRAINTS. PSFASTNOISELITE ISN'T JUST A SIMPLE
# DIALECT TRANSLATION. MODIFICATIONS HAVE BEEN MADE IN AN ATTEMPT TO OPTIMIZE
# FOR PERFORMANCE WHILE RETAINING THE INTEGRITY OF THE OUTPUT. THE FOLLOWING
# LIST DETAILS SOME OF THE MORE IMPORTANT DEVIATIONS:
#
# - ALL INSTANCES OF FLOAT HAVE BEEN CHANGED TO SINGLE.
# - ALL INSTANCES OF INT HAVE BEEN CHANGED TO INT64. THIS IS TO HELP AVOID
#   STATEMENTS THAT COULD POTENTIALLY RESULT IN OVERFLOWS WHEN USING SIMPLY INT
#   SINCE IT MASKS TO INT32.
# - REDUNDANT CASTS OF EXPRESSIONS ARE REMOVED, ESPECIALLY IN PLACES WHERE ALL
#   OPERANDS ARE OF THE SAME TYPE, OR WHERE A LITERAL WOULD BE INFERRED
#   CORRECTLY GIVEN THE OPERANDS, OPERATION(S), AND TYPE OF STORAGE FOR
#   ASSIGNMENT.
# - POWERSHELL DOESN'T SUPPORT COMPOUND BITWISE ARITHMETIC OPERATORS. IN PLACES
#   WHERE THOSE WERE ENCOUNTERED, THE EXPRESSION HAS BEEN EXPANDED.
#
# THE ORIGINAL SOURCE CODE FOR FAST NOISE LITE CAN BE FOUND AT THEIR GITHUB
# REPOSITORY: https://github.com/Auburn/FastNoiseLite
#
#
#
# HOW TO USE
#
# MODULARIZING CLASSES IN POWERSHELL CAN BE TROUBLESOME, SO IT'S BEST IF THIS
# CODE IS COPIED/PASTED INTO THE PROGRAM IN WHICH IT'S INTENDED TO BE USED IN.
# COPY EVERYTHING FROM LINE 38 DOWN.
###############################################################################
Set-StrictMode -Version Latest

Enum FnlNoiseType {
    OpenSimplex2
    OpenSimplex2S
    Cellular
    Perlin
    ValueCubic
    Value
}

Enum FnlRotationType3D {
    None
    ImproveXYPlanes
    ImproveXZPlanes
}

Enum FnlFractalType {
    None
    FBm
    Ridged
    PingPong
    DomainWarpProgressive
    DomainWarpIndependent
}

Enum FnlCellularDistanceFunction {
    Euclidean
    EuclideanSq
    Manhattan
    Hybrid
}

Enum FnlCellularReturnType {
    CellValue
    Distance
    Distance2
    Distance2Add
    Distance2Sub
    Distance2Mul
    Distance2Div
}

Enum FnlDomainWarpType {
    OpenSimplex2
    OpenSimplex2Reduced
    BasicGrid
}

Enum FnlTransformType3D {
    None
    ImproveXYPlanes
    ImproveXZPlanes
    DefaultOpenSimplex2
}

Class FastNoiseLite {
    Static [Int64]$PRIMEX         = 501125321
    Static [Int64]$PRIMEY         = 1136930381
    Static [Int64]$PRIMEZ         = 1720413743
    Static [Int64]$HASH_MAGIC     = 0x27D4EB2D
    Static [Int64]$HASHCALC_MAGIC = 2147483648
    Static [Int64]$SEEDADD_MAGIC  = 1293373
    Static [Int64]$APRIMEXMULT2   = [FastNoiseLite]::PRIMEX * 2
    Static [Int64]$APRIMEYMULT2   = [FastNoiseLite]::PRIMEY * 2
    Static [Int64]$APRIMEZMULT2   = [FastNoiseLite]::PRIMEZ * 2
    
    Static [Single]$SQRT3                     = 1.7320508075688772935274463415059
    Static [Single]$PLANARIMPROVEA_MAGIC      = 0.211324865405187
    Static [Single]$PLANARIMPROVEZSCALE_MAGIC = 0.577350269189626
    Static [Single]$SIMPLEXVALMODA_MAGIC      = 32.69428253173828125
    Static [Single]$A2DIV3                    = 2 / 3

    Static [Single[]]$GRADIENTS2D = @(
        0.130526192220052,  0.99144486137381,   0.38268343236509,   0.923879532511287,  0.608761429008721,  0.793353340291235,  0.793353340291235,  0.608761429008721,
        0.923879532511287,  0.38268343236509,   0.99144486137381,   0.130526192220051,  0.99144486137381,  -0.130526192220051,  0.923879532511287, -0.38268343236509,
        0.793353340291235, -0.60876142900872,   0.608761429008721, -0.793353340291235,  0.38268343236509,  -0.923879532511287,  0.130526192220052, -0.99144486137381,
        -0.130526192220052, -0.99144486137381,  -0.38268343236509,  -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
        -0.923879532511287, -0.38268343236509,  -0.99144486137381,  -0.130526192220052, -0.99144486137381,   0.130526192220051, -0.923879532511287,  0.38268343236509,
        -0.793353340291235,  0.608761429008721, -0.608761429008721,  0.793353340291235, -0.38268343236509,   0.923879532511287, -0.130526192220052,  0.99144486137381,
        0.130526192220052,  0.99144486137381,   0.38268343236509,   0.923879532511287,  0.608761429008721,  0.793353340291235,  0.793353340291235,  0.608761429008721,
        0.923879532511287,  0.38268343236509,   0.99144486137381,   0.130526192220051,  0.99144486137381,  -0.130526192220051,  0.923879532511287, -0.38268343236509,
        0.793353340291235, -0.60876142900872,   0.608761429008721, -0.793353340291235,  0.38268343236509,  -0.923879532511287,  0.130526192220052, -0.99144486137381,
        -0.130526192220052, -0.99144486137381,  -0.38268343236509,  -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
        -0.923879532511287, -0.38268343236509,  -0.99144486137381,  -0.130526192220052, -0.99144486137381,   0.130526192220051, -0.923879532511287,  0.38268343236509,
        -0.793353340291235,  0.608761429008721, -0.608761429008721,  0.793353340291235, -0.38268343236509,   0.923879532511287, -0.130526192220052,  0.99144486137381,
        0.130526192220052,  0.99144486137381,   0.38268343236509,   0.923879532511287,  0.608761429008721,  0.793353340291235,  0.793353340291235,  0.608761429008721,
        0.923879532511287,  0.38268343236509,   0.99144486137381,   0.130526192220051,  0.99144486137381,  -0.130526192220051,  0.923879532511287, -0.38268343236509,
        0.793353340291235, -0.60876142900872,   0.608761429008721, -0.793353340291235,  0.38268343236509,  -0.923879532511287,  0.130526192220052, -0.99144486137381,
        -0.130526192220052, -0.99144486137381,  -0.38268343236509,  -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
        -0.923879532511287, -0.38268343236509,  -0.99144486137381,  -0.130526192220052, -0.99144486137381,   0.130526192220051, -0.923879532511287,  0.38268343236509,
        -0.793353340291235,  0.608761429008721, -0.608761429008721,  0.793353340291235, -0.38268343236509,   0.923879532511287, -0.130526192220052,  0.99144486137381,
        0.130526192220052,  0.99144486137381,   0.38268343236509,   0.923879532511287,  0.608761429008721,  0.793353340291235,  0.793353340291235,  0.608761429008721,
        0.923879532511287,  0.38268343236509,   0.99144486137381,   0.130526192220051,  0.99144486137381,  -0.130526192220051,  0.923879532511287, -0.38268343236509,
        0.793353340291235, -0.60876142900872,   0.608761429008721, -0.793353340291235,  0.38268343236509,  -0.923879532511287,  0.130526192220052, -0.99144486137381,
        -0.130526192220052, -0.99144486137381,  -0.38268343236509,  -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
        -0.923879532511287, -0.38268343236509,  -0.99144486137381,  -0.130526192220052, -0.99144486137381,   0.130526192220051, -0.923879532511287,  0.38268343236509,
        -0.793353340291235,  0.608761429008721, -0.608761429008721,  0.793353340291235, -0.38268343236509,   0.923879532511287, -0.130526192220052,  0.99144486137381,
        0.130526192220052,  0.99144486137381,   0.38268343236509,   0.923879532511287,  0.608761429008721,  0.793353340291235,  0.793353340291235,  0.608761429008721,
        0.923879532511287,  0.38268343236509,   0.99144486137381,   0.130526192220051,  0.99144486137381,  -0.130526192220051,  0.923879532511287, -0.38268343236509,
        0.793353340291235, -0.60876142900872,   0.608761429008721, -0.793353340291235,  0.38268343236509,  -0.923879532511287,  0.130526192220052, -0.99144486137381,
        -0.130526192220052, -0.99144486137381,  -0.38268343236509,  -0.923879532511287, -0.608761429008721, -0.793353340291235, -0.793353340291235, -0.608761429008721,
        -0.923879532511287, -0.38268343236509,  -0.99144486137381,  -0.130526192220052, -0.99144486137381,   0.130526192220051, -0.923879532511287,  0.38268343236509,
        -0.793353340291235,  0.608761429008721, -0.608761429008721,  0.793353340291235, -0.38268343236509,   0.923879532511287, -0.130526192220052,  0.99144486137381,
        0.38268343236509,   0.923879532511287,  0.923879532511287,  0.38268343236509,   0.923879532511287, -0.38268343236509,   0.38268343236509,  -0.923879532511287,
        -0.38268343236509,  -0.923879532511287, -0.923879532511287, -0.38268343236509,  -0.923879532511287,  0.38268343236509,  -0.38268343236509,   0.923879532511287
    )

    Static [Single[]]$RANDVECS2D = @(
        -0.2700222198, -0.9628540911, 0.3863092627, -0.9223693152, 0.04444859006, -0.999011673, -0.5992523158, -0.8005602176, -0.7819280288, 0.6233687174, 0.9464672271, 0.3227999196, -0.6514146797, -0.7587218957, 0.9378472289, 0.347048376,
        -0.8497875957, -0.5271252623, -0.879042592, 0.4767432447, -0.892300288, -0.4514423508, -0.379844434, -0.9250503802, -0.9951650832, 0.0982163789, 0.7724397808, -0.6350880136, 0.7573283322, -0.6530343002, -0.9928004525, -0.119780055,
        -0.0532665713, 0.9985803285, 0.9754253726, -0.2203300762, -0.7665018163, 0.6422421394, 0.991636706, 0.1290606184, -0.994696838, 0.1028503788, -0.5379205513, -0.84299554, 0.5022815471, -0.8647041387, 0.4559821461, -0.8899889226,
        -0.8659131224, -0.5001944266, 0.0879458407, -0.9961252577, -0.5051684983, 0.8630207346, 0.7753185226, -0.6315704146, -0.6921944612, 0.7217110418, -0.5191659449, -0.8546734591, 0.8978622882, -0.4402764035, -0.1706774107, 0.9853269617,
        -0.9353430106, -0.3537420705, -0.9992404798, 0.03896746794, -0.2882064021, -0.9575683108, -0.9663811329, 0.2571137995, -0.8759714238, -0.4823630009, -0.8303123018, -0.5572983775, 0.05110133755, -0.9986934731, -0.8558373281, -0.5172450752,
        0.09887025282, 0.9951003332, 0.9189016087, 0.3944867976, -0.2439375892, -0.9697909324, -0.8121409387, -0.5834613061, -0.9910431363, 0.1335421355, 0.8492423985, -0.5280031709, -0.9717838994, -0.2358729591, 0.9949457207, 0.1004142068,
        0.6241065508, -0.7813392434, 0.662910307, 0.7486988212, -0.7197418176, 0.6942418282, -0.8143370775, -0.5803922158, 0.104521054, -0.9945226741, -0.1065926113, -0.9943027784, 0.445799684, -0.8951327509, 0.105547406, 0.9944142724,
        -0.992790267, 0.1198644477, -0.8334366408, 0.552615025, 0.9115561563, -0.4111755999, 0.8285544909, -0.5599084351, 0.7217097654, -0.6921957921, 0.4940492677, -0.8694339084, -0.3652321272, -0.9309164803, -0.9696606758, 0.2444548501,
        0.08925509731, -0.996008799, 0.5354071276, -0.8445941083, -0.1053576186, 0.9944343981, -0.9890284586, 0.1477251101, 0.004856104961, 0.9999882091, 0.9885598478, 0.1508291331, 0.9286129562, -0.3710498316, -0.5832393863, -0.8123003252,
        0.3015207509, 0.9534596146, -0.9575110528, 0.2883965738, 0.9715802154, -0.2367105511, 0.229981792, 0.9731949318, 0.955763816, -0.2941352207, 0.740956116, 0.6715534485, -0.9971513787, -0.07542630764, 0.6905710663, -0.7232645452,
        -0.290713703, -0.9568100872, 0.5912777791, -0.8064679708, -0.9454592212, -0.325740481, 0.6664455681, 0.74555369, 0.6236134912, 0.7817328275, 0.9126993851, -0.4086316587, -0.8191762011, 0.5735419353, -0.8812745759, -0.4726046147,
        0.9953313627, 0.09651672651, 0.9855650846, -0.1692969699, -0.8495980887, 0.5274306472, 0.6174853946, -0.7865823463, 0.8508156371, 0.52546432, 0.9985032451, -0.05469249926, 0.1971371563, -0.9803759185, 0.6607855748, -0.7505747292,
        -0.03097494063, 0.9995201614, -0.6731660801, 0.739491331, -0.7195018362, -0.6944905383, 0.9727511689, 0.2318515979, 0.9997059088, -0.0242506907, 0.4421787429, -0.8969269532, 0.9981350961, -0.061043673, -0.9173660799, -0.3980445648,
        -0.8150056635, -0.5794529907, -0.8789331304, 0.4769450202, 0.0158605829, 0.999874213, -0.8095464474, 0.5870558317, -0.9165898907, -0.3998286786, -0.8023542565, 0.5968480938, -0.5176737917, 0.8555780767, -0.8154407307, -0.5788405779,
        0.4022010347, -0.9155513791, -0.9052556868, -0.4248672045, 0.7317445619, 0.6815789728, -0.5647632201, -0.8252529947, -0.8403276335, -0.5420788397, -0.9314281527, 0.363925262, 0.5238198472, 0.8518290719, 0.7432803869, -0.6689800195,
        -0.985371561, -0.1704197369, 0.4601468731, 0.88784281, 0.825855404, 0.5638819483, 0.6182366099, 0.7859920446, 0.8331502863, -0.553046653, 0.1500307506, 0.9886813308, -0.662330369, -0.7492119075, -0.668598664, 0.743623444,
        0.7025606278, 0.7116238924, -0.5419389763, -0.8404178401, -0.3388616456, 0.9408362159, 0.8331530315, 0.5530425174, -0.2989720662, -0.9542618632, 0.2638522993, 0.9645630949, 0.124108739, -0.9922686234, -0.7282649308, -0.6852956957,
        0.6962500149, 0.7177993569, -0.9183535368, 0.3957610156, -0.6326102274, -0.7744703352, -0.9331891859, -0.359385508, -0.1153779357, -0.9933216659, 0.9514974788, -0.3076565421, -0.08987977445, -0.9959526224, 0.6678496916, 0.7442961705,
        0.7952400393, -0.6062947138, -0.6462007402, -0.7631674805, -0.2733598753, 0.9619118351, 0.9669590226, -0.254931851, -0.9792894595, 0.2024651934, -0.5369502995, -0.8436138784, -0.270036471, -0.9628500944, -0.6400277131, 0.7683518247,
        -0.7854537493, -0.6189203566, 0.06005905383, -0.9981948257, -0.02455770378, 0.9996984141, -0.65983623, 0.751409442, -0.6253894466, -0.7803127835, -0.6210408851, -0.7837781695, 0.8348888491, 0.5504185768, -0.1592275245, 0.9872419133,
        0.8367622488, 0.5475663786, -0.8675753916, -0.4973056806, -0.2022662628, -0.9793305667, 0.9399189937, 0.3413975472, 0.9877404807, -0.1561049093, -0.9034455656, 0.4287028224, 0.1269804218, -0.9919052235, -0.3819600854, 0.924178821,
        0.9754625894, 0.2201652486, -0.3204015856, -0.9472818081, -0.9874760884, 0.1577687387, 0.02535348474, -0.9996785487, 0.4835130794, -0.8753371362, -0.2850799925, -0.9585037287, -0.06805516006, -0.99768156, -0.7885244045, -0.6150034663,
        0.3185392127, -0.9479096845, 0.8880043089, 0.4598351306, 0.6476921488, -0.7619021462, 0.9820241299, 0.1887554194, 0.9357275128, -0.3527237187, -0.8894895414, 0.4569555293, 0.7922791302, 0.6101588153, 0.7483818261, 0.6632681526,
        -0.7288929755, -0.6846276581, 0.8729032783, -0.4878932944, 0.8288345784, 0.5594937369, 0.08074567077, 0.9967347374, 0.9799148216, -0.1994165048, -0.580730673, -0.8140957471, -0.4700049791, -0.8826637636, 0.2409492979, 0.9705377045,
        0.9437816757, -0.3305694308, -0.8927998638, -0.4504535528, -0.8069622304, 0.5906030467, 0.06258973166, 0.9980393407, -0.9312597469, 0.3643559849, 0.5777449785, 0.8162173362, -0.3360095855, -0.941858566, 0.697932075, -0.7161639607,
        -0.002008157227, -0.9999979837, -0.1827294312, -0.9831632392, -0.6523911722, 0.7578824173, -0.4302626911, -0.9027037258, -0.9985126289, -0.05452091251, -0.01028102172, -0.9999471489, -0.4946071129, 0.8691166802, -0.2999350194, 0.9539596344,
        0.8165471961, 0.5772786819, 0.2697460475, 0.962931498, -0.7306287391, -0.6827749597, -0.7590952064, -0.6509796216, -0.907053853, 0.4210146171, -0.5104861064, -0.8598860013, 0.8613350597, 0.5080373165, 0.5007881595, -0.8655698812,
        -0.654158152, 0.7563577938, -0.8382755311, -0.545246856, 0.6940070834, 0.7199681717, 0.06950936031, 0.9975812994, 0.1702942185, -0.9853932612, 0.2695973274, 0.9629731466, 0.5519612192, -0.8338697815, 0.225657487, -0.9742067022,
        0.4215262855, -0.9068161835, 0.4881873305, -0.8727388672, -0.3683854996, -0.9296731273, -0.9825390578, 0.1860564427, 0.81256471, 0.5828709909, 0.3196460933, -0.9475370046, 0.9570913859, 0.2897862643, -0.6876655497, -0.7260276109,
        -0.9988770922, -0.047376731, -0.1250179027, 0.992154486, -0.8280133617, 0.560708367, 0.9324863769, -0.3612051451, 0.6394653183, 0.7688199442, -0.01623847064, -0.9998681473, -0.9955014666, -0.09474613458, -0.81453315, 0.580117012,
        0.4037327978, -0.9148769469, 0.9944263371, 0.1054336766, -0.1624711654, 0.9867132919, -0.9949487814, -0.100383875, -0.6995302564, 0.7146029809, 0.5263414922, -0.85027327, -0.5395221479, 0.841971408, 0.6579370318, 0.7530729462,
        0.01426758847, -0.9998982128, -0.6734383991, 0.7392433447, 0.639412098, -0.7688642071, 0.9211571421, 0.3891908523, -0.146637214, -0.9891903394, -0.782318098, 0.6228791163, -0.5039610839, -0.8637263605, -0.7743120191, -0.6328039957
    )

    Static [Single[]]$GRADIENTS3D = @(
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        0, 1, 1, 0,  0,-1, 1, 0,  0, 1,-1, 0,  0,-1,-1, 0,
        1, 0, 1, 0, -1, 0, 1, 0,  1, 0,-1, 0, -1, 0,-1, 0,
        1, 1, 0, 0, -1, 1, 0, 0,  1,-1, 0, 0, -1,-1, 0, 0,
        1, 1, 0, 0,  0,-1, 1, 0, -1, 1, 0, 0,  0,-1,-1, 0
    )

    Static [Single[]]$RANDVECS3D = @(
        -0.7292736885, -0.6618439697, 0.1735581948, 0, 0.790292081, -0.5480887466, -0.2739291014, 0, 0.7217578935, 0.6226212466, -0.3023380997, 0, 0.565683137, -0.8208298145, -0.0790000257, 0, 0.760049034, -0.5555979497, -0.3370999617, 0, 0.3713945616, 0.5011264475, 0.7816254623, 0, -0.1277062463, -0.4254438999, -0.8959289049, 0, -0.2881560924, -0.5815838982, 0.7607405838, 0,
        0.5849561111, -0.662820239, -0.4674352136, 0, 0.3307171178, 0.0391653737, 0.94291689, 0, 0.8712121778, -0.4113374369, -0.2679381538, 0, 0.580981015, 0.7021915846, 0.4115677815, 0, 0.503756873, 0.6330056931, -0.5878203852, 0, 0.4493712205, 0.601390195, 0.6606022552, 0, -0.6878403724, 0.09018890807, -0.7202371714, 0, -0.5958956522, -0.6469350577, 0.475797649, 0,
        -0.5127052122, 0.1946921978, -0.8361987284, 0, -0.9911507142, -0.05410276466, -0.1212153153, 0, -0.2149721042, 0.9720882117, -0.09397607749, 0, -0.7518650936, -0.5428057603, 0.3742469607, 0, 0.5237068895, 0.8516377189, -0.02107817834, 0, 0.6333504779, 0.1926167129, -0.7495104896, 0, -0.06788241606, 0.3998305789, 0.9140719259, 0, -0.5538628599, -0.4729896695, -0.6852128902, 0,
        -0.7261455366, -0.5911990757, 0.3509933228, 0, -0.9229274737, -0.1782808786, 0.3412049336, 0, -0.6968815002, 0.6511274338, 0.3006480328, 0, 0.9608044783, -0.2098363234, -0.1811724921, 0, 0.06817146062, -0.9743405129, 0.2145069156, 0, -0.3577285196, -0.6697087264, -0.6507845481, 0, -0.1868621131, 0.7648617052, -0.6164974636, 0, -0.6541697588, 0.3967914832, 0.6439087246, 0,
        0.6993340405, -0.6164538506, 0.3618239211, 0, -0.1546665739, 0.6291283928, 0.7617583057, 0, -0.6841612949, -0.2580482182, -0.6821542638, 0, 0.5383980957, 0.4258654885, 0.7271630328, 0, -0.5026987823, -0.7939832935, -0.3418836993, 0, 0.3202971715, 0.2834415347, 0.9039195862, 0, 0.8683227101, -0.0003762656404, -0.4959995258, 0, 0.791120031, -0.08511045745, 0.6057105799, 0,
        -0.04011016052, -0.4397248749, 0.8972364289, 0, 0.9145119872, 0.3579346169, -0.1885487608, 0, -0.9612039066, -0.2756484276, 0.01024666929, 0, 0.6510361721, -0.2877799159, -0.7023778346, 0, -0.2041786351, 0.7365237271, 0.644859585, 0, -0.7718263711, 0.3790626912, 0.5104855816, 0, -0.3060082741, -0.7692987727, 0.5608371729, 0, 0.454007341, -0.5024843065, 0.7357899537, 0,
        0.4816795475, 0.6021208291, -0.6367380315, 0, 0.6961980369, -0.3222197429, 0.641469197, 0, -0.6532160499, -0.6781148932, 0.3368515753, 0, 0.5089301236, -0.6154662304, -0.6018234363, 0, -0.1635919754, -0.9133604627, -0.372840892, 0, 0.52408019, -0.8437664109, 0.1157505864, 0, 0.5902587356, 0.4983817807, -0.6349883666, 0, 0.5863227872, 0.494764745, 0.6414307729, 0,
        0.6779335087, 0.2341345225, 0.6968408593, 0, 0.7177054546, -0.6858979348, 0.120178631, 0, -0.5328819713, -0.5205125012, 0.6671608058, 0, -0.8654874251, -0.0700727088, -0.4960053754, 0, -0.2861810166, 0.7952089234, 0.5345495242, 0, -0.04849529634, 0.9810836427, -0.1874115585, 0, -0.6358521667, 0.6058348682, 0.4781800233, 0, 0.6254794696, -0.2861619734, 0.7258696564, 0,
        -0.2585259868, 0.5061949264, -0.8227581726, 0, 0.02136306781, 0.5064016808, -0.8620330371, 0, 0.200111773, 0.8599263484, 0.4695550591, 0, 0.4743561372, 0.6014985084, -0.6427953014, 0, 0.6622993731, -0.5202474575, -0.5391679918, 0, 0.08084972818, -0.6532720452, 0.7527940996, 0, -0.6893687501, 0.0592860349, 0.7219805347, 0, -0.1121887082, -0.9673185067, 0.2273952515, 0,
        0.7344116094, 0.5979668656, -0.3210532909, 0, 0.5789393465, -0.2488849713, 0.7764570201, 0, 0.6988182827, 0.3557169806, -0.6205791146, 0, -0.8636845529, -0.2748771249, -0.4224826141, 0, -0.4247027957, -0.4640880967, 0.777335046, 0, 0.5257722489, -0.8427017621, 0.1158329937, 0, 0.9343830603, 0.316302472, -0.1639543925, 0, -0.1016836419, -0.8057303073, -0.5834887393, 0,
        -0.6529238969, 0.50602126, -0.5635892736, 0, -0.2465286165, -0.9668205684, -0.06694497494, 0, -0.9776897119, -0.2099250524, -0.007368825344, 0, 0.7736893337, 0.5734244712, 0.2694238123, 0, -0.6095087895, 0.4995678998, 0.6155736747, 0, 0.5794535482, 0.7434546771, 0.3339292269, 0, -0.8226211154, 0.08142581855, 0.5627293636, 0, -0.510385483, 0.4703667658, 0.7199039967, 0,
        -0.5764971849, -0.07231656274, -0.8138926898, 0, 0.7250628871, 0.3949971505, -0.5641463116, 0, -0.1525424005, 0.4860840828, -0.8604958341, 0, -0.5550976208, -0.4957820792, 0.667882296, 0, -0.1883614327, 0.9145869398, 0.357841725, 0, 0.7625556724, -0.5414408243, -0.3540489801, 0, -0.5870231946, -0.3226498013, -0.7424963803, 0, 0.3051124198, 0.2262544068, -0.9250488391, 0,
        0.6379576059, 0.577242424, -0.5097070502, 0, -0.5966775796, 0.1454852398, -0.7891830656, 0, -0.658330573, 0.6555487542, -0.3699414651, 0, 0.7434892426, 0.2351084581, 0.6260573129, 0, 0.5562114096, 0.8264360377, -0.0873632843, 0, -0.3028940016, -0.8251527185, 0.4768419182, 0, 0.1129343818, -0.985888439, -0.1235710781, 0, 0.5937652891, -0.5896813806, 0.5474656618, 0,
        0.6757964092, -0.5835758614, -0.4502648413, 0, 0.7242302609, -0.1152719764, 0.6798550586, 0, -0.9511914166, 0.0753623979, -0.2992580792, 0, 0.2539470961, -0.1886339355, 0.9486454084, 0, 0.571433621, -0.1679450851, -0.8032795685, 0, -0.06778234979, 0.3978269256, 0.9149531629, 0, 0.6074972649, 0.733060024, -0.3058922593, 0, -0.5435478392, 0.1675822484, 0.8224791405, 0,
        -0.5876678086, -0.3380045064, -0.7351186982, 0, -0.7967562402, 0.04097822706, -0.6029098428, 0, -0.1996350917, 0.8706294745, 0.4496111079, 0, -0.02787660336, -0.9106232682, -0.4122962022, 0, -0.7797625996, -0.6257634692, 0.01975775581, 0, -0.5211232846, 0.7401644346, -0.4249554471, 0, 0.8575424857, 0.4053272873, -0.3167501783, 0, 0.1045223322, 0.8390195772, -0.5339674439, 0,
        0.3501822831, 0.9242524096, -0.1520850155, 0, 0.1987849858, 0.07647613266, 0.9770547224, 0, 0.7845996363, 0.6066256811, -0.1280964233, 0, 0.09006737436, -0.9750989929, -0.2026569073, 0, -0.8274343547, -0.542299559, 0.1458203587, 0, -0.3485797732, -0.415802277, 0.840000362, 0, -0.2471778936, -0.7304819962, -0.6366310879, 0, -0.3700154943, 0.8577948156, 0.3567584454, 0,
        0.5913394901, -0.548311967, -0.5913303597, 0, 0.1204873514, -0.7626472379, -0.6354935001, 0, 0.616959265, 0.03079647928, 0.7863922953, 0, 0.1258156836, -0.6640829889, -0.7369967419, 0, -0.6477565124, -0.1740147258, -0.7417077429, 0, 0.6217889313, -0.7804430448, -0.06547655076, 0, 0.6589943422, -0.6096987708, 0.4404473475, 0, -0.2689837504, -0.6732403169, -0.6887635427, 0,
        -0.3849775103, 0.5676542638, 0.7277093879, 0, 0.5754444408, 0.8110471154, -0.1051963504, 0, 0.9141593684, 0.3832947817, 0.131900567, 0, -0.107925319, 0.9245493968, 0.3654593525, 0, 0.377977089, 0.3043148782, 0.8743716458, 0, -0.2142885215, -0.8259286236, 0.5214617324, 0, 0.5802544474, 0.4148098596, -0.7008834116, 0, -0.1982660881, 0.8567161266, -0.4761596756, 0,
        -0.03381553704, 0.3773180787, -0.9254661404, 0, -0.6867922841, -0.6656597827, 0.2919133642, 0, 0.7731742607, -0.2875793547, -0.5652430251, 0, -0.09655941928, 0.9193708367, -0.3813575004, 0, 0.2715702457, -0.9577909544, -0.09426605581, 0, 0.2451015704, -0.6917998565, -0.6792188003, 0, 0.977700782, -0.1753855374, 0.1155036542, 0, -0.5224739938, 0.8521606816, 0.02903615945, 0,
        -0.7734880599, -0.5261292347, 0.3534179531, 0, -0.7134492443, -0.269547243, 0.6467878011, 0, 0.1644037271, 0.5105846203, -0.8439637196, 0, 0.6494635788, 0.05585611296, 0.7583384168, 0, -0.4711970882, 0.5017280509, -0.7254255765, 0, -0.6335764307, -0.2381686273, -0.7361091029, 0, -0.9021533097, -0.270947803, -0.3357181763, 0, -0.3793711033, 0.872258117, 0.3086152025, 0,
        -0.6855598966, -0.3250143309, 0.6514394162, 0, 0.2900942212, -0.7799057743, -0.5546100667, 0, -0.2098319339, 0.85037073, 0.4825351604, 0, -0.4592603758, 0.6598504336, -0.5947077538, 0, 0.8715945488, 0.09616365406, -0.4807031248, 0, -0.6776666319, 0.7118504878, -0.1844907016, 0, 0.7044377633, 0.312427597, 0.637304036, 0, -0.7052318886, -0.2401093292, -0.6670798253, 0,
        0.081921007, -0.7207336136, -0.6883545647, 0, -0.6993680906, -0.5875763221, -0.4069869034, 0, -0.1281454481, 0.6419895885, 0.7559286424, 0, -0.6337388239, -0.6785471501, -0.3714146849, 0, 0.5565051903, -0.2168887573, -0.8020356851, 0, -0.5791554484, 0.7244372011, -0.3738578718, 0, 0.1175779076, -0.7096451073, 0.6946792478, 0, -0.6134619607, 0.1323631078, 0.7785527795, 0,
        0.6984635305, -0.02980516237, -0.715024719, 0, 0.8318082963, -0.3930171956, 0.3919597455, 0, 0.1469576422, 0.05541651717, -0.9875892167, 0, 0.708868575, -0.2690503865, 0.6520101478, 0, 0.2726053183, 0.67369766, -0.68688995, 0, -0.6591295371, 0.3035458599, -0.6880466294, 0, 0.4815131379, -0.7528270071, 0.4487723203, 0, 0.9430009463, 0.1675647412, -0.2875261255, 0,
        0.434802957, 0.7695304522, -0.4677277752, 0, 0.3931996188, 0.594473625, 0.7014236729, 0, 0.7254336655, -0.603925654, 0.3301814672, 0, 0.7590235227, -0.6506083235, 0.02433313207, 0, -0.8552768592, -0.3430042733, 0.3883935666, 0, -0.6139746835, 0.6981725247, 0.3682257648, 0, -0.7465905486, -0.5752009504, 0.3342849376, 0, 0.5730065677, 0.810555537, -0.1210916791, 0,
        -0.9225877367, -0.3475211012, -0.167514036, 0, -0.7105816789, -0.4719692027, -0.5218416899, 0, -0.08564609717, 0.3583001386, 0.929669703, 0, -0.8279697606, -0.2043157126, 0.5222271202, 0, 0.427944023, 0.278165994, 0.8599346446, 0, 0.5399079671, -0.7857120652, -0.3019204161, 0, 0.5678404253, -0.5495413974, -0.6128307303, 0, -0.9896071041, 0.1365639107, -0.04503418428, 0,
        -0.6154342638, -0.6440875597, 0.4543037336, 0, 0.1074204368, -0.7946340692, 0.5975094525, 0, -0.3595449969, -0.8885529948, 0.28495784, 0, -0.2180405296, 0.1529888965, 0.9638738118, 0, -0.7277432317, -0.6164050508, -0.3007234646, 0, 0.7249729114, -0.00669719484, 0.6887448187, 0, -0.5553659455, -0.5336586252, 0.6377908264, 0, 0.5137558015, 0.7976208196, -0.3160000073, 0,
        -0.3794024848, 0.9245608561, -0.03522751494, 0, 0.8229248658, 0.2745365933, -0.4974176556, 0, -0.5404114394, 0.6091141441, 0.5804613989, 0, 0.8036581901, -0.2703029469, 0.5301601931, 0, 0.6044318879, 0.6832968393, 0.4095943388, 0, 0.06389988817, 0.9658208605, -0.2512108074, 0, 0.1087113286, 0.7402471173, -0.6634877936, 0, -0.713427712, -0.6926784018, 0.1059128479, 0,
        0.6458897819, -0.5724548511, -0.5050958653, 0, -0.6553931414, 0.7381471625, 0.159995615, 0, 0.3910961323, 0.9188871375, -0.05186755998, 0, -0.4879022471, -0.5904376907, 0.6429111375, 0, 0.6014790094, 0.7707441366, -0.2101820095, 0, -0.5677173047, 0.7511360995, 0.3368851762, 0, 0.7858573506, 0.226674665, 0.5753666838, 0, -0.4520345543, -0.604222686, -0.6561857263, 0,
        0.002272116345, 0.4132844051, -0.9105991643, 0, -0.5815751419, -0.5162925989, 0.6286591339, 0, -0.03703704785, 0.8273785755, 0.5604221175, 0, -0.5119692504, 0.7953543429, -0.3244980058, 0, -0.2682417366, -0.9572290247, -0.1084387619, 0, -0.2322482736, -0.9679131102, -0.09594243324, 0, 0.3554328906, -0.8881505545, 0.2913006227, 0, 0.7346520519, -0.4371373164, 0.5188422971, 0,
        0.9985120116, 0.04659011161, -0.02833944577, 0, -0.3727687496, -0.9082481361, 0.1900757285, 0, 0.91737377, -0.3483642108, 0.1925298489, 0, 0.2714911074, 0.4147529736, -0.8684886582, 0, 0.5131763485, -0.7116334161, 0.4798207128, 0, -0.8737353606, 0.18886992, -0.4482350644, 0, 0.8460043821, -0.3725217914, 0.3814499973, 0, 0.8978727456, -0.1780209141, -0.4026575304, 0,
        0.2178065647, -0.9698322841, -0.1094789531, 0, -0.1518031304, -0.7788918132, -0.6085091231, 0, -0.2600384876, -0.4755398075, -0.8403819825, 0, 0.572313509, -0.7474340931, -0.3373418503, 0, -0.7174141009, 0.1699017182, -0.6756111411, 0, -0.684180784, 0.02145707593, -0.7289967412, 0, -0.2007447902, 0.06555605789, -0.9774476623, 0, -0.1148803697, -0.8044887315, 0.5827524187, 0,
        -0.7870349638, 0.03447489231, 0.6159443543, 0, -0.2015596421, 0.6859872284, 0.6991389226, 0, -0.08581082512, -0.10920836, -0.9903080513, 0, 0.5532693395, 0.7325250401, -0.396610771, 0, -0.1842489331, -0.9777375055, -0.1004076743, 0, 0.0775473789, -0.9111505856, 0.4047110257, 0, 0.1399838409, 0.7601631212, -0.6344734459, 0, 0.4484419361, -0.845289248, 0.2904925424, 0
    )

    [Int64]$Seed                                           = 1337
    [Int64]$Octaves                                        = 3
    [Single]$Frequency                                     = 0.01
    [Single]$Lacunarity                                    = 2
    [Single]$Gain                                          = 0.5
    [Single]$WeightedStrength                              = 0
    [Single]$PingPongStrength                              = 2
    [Single]$FractalBounding                               = 1 / 1.75
    [Single]$CellularJitterModifier                        = 1
    [Single]$DomainWarpAmp                                 = 1
    [FnlNoiseType]$NoiseType                               = [FnlNoiseType]::OpenSimplex2
    [FnlRotationType3D]$RotationType3D                     = [FnlRotationType3D]::None
    [FnlTransformType3D]$TransformType3D                   = [FnlTransformType3D]::DefaultOpenSimplex2
    [FnlTransformType3D]$WarpTransformType3D               = [FnlTransformType3D]::DefaultOpenSimplex2
    [FnlFractalType]$FractalType                           = [FnlFractalType]::None
    [FnlCellularDistanceFunction]$CellularDistanceFunction = [FnlCellularDistanceFunction]::EuclideanSq
    [FnlCellularReturnType]$CellularReturnType             = [FnlCellularReturnType]::Distance
    [FnlDomainWarpType]$DomainWarpType                     = [FnlDomainWarpType]::OpenSimplex2

    FastNoiseLite() {}

    ###########################################################################
    #
    # NOTE THAT THE FOLLOWING METHODS WERE INLINED IN THE C# SOURCE.
    # POWERSHELL DOESN'T SUPPORT INLINING, SO THERE *MAY* BE SOME PERFORMANCE
    # DECAY HERE.
    #
    ###########################################################################
    Static [Single]FastMin(
        [Single]$A,
        [Single]$B
    ) {
        Return $A -LT $B ? $A : $B
    }

    Static [Single]FastMax(
        [Single]$A,
        [Single]$B
    ) {
        Return $A -GT $B ? $A : $B
    }

    Static [Single]FastAbs(
        [Single]$F
    ) {
        Return $F -LT 0 ? $F * -1 : $F
    }

    Static [Single]FastSqrt(
        [Single]$F
    ) {
        Return ([Single]([System.Math]::Sqrt($F))) # SQRT RETURNS DOUBLE, SO THIS CAST MAY MAKE SENSE, BUT WE MAY LOSE RESOLUTION
    }

    Static [Int64]FastFloor(
        [Single]$F
    ) {
        Return $F -GE 0 ? ([Int64]$F) : ([Int64]$F) - 1
    }

    Static [Int64]FastRound(
        [Single]$F
    ) {
        Return $F -GE 0 ? ([Int64]($F + 0.5)) : ([Int64]($F - 0.5))
    }

    Static [Single]Lerp(
        [Single]$A,
        [Single]$B,
        [Single]$T
    ) {
        Return $A + $T * ($B - $A)
    }

    Static [Single]InterpHermite(
        [Single]$T
    ) {
        Return $T * $T * (3 - 2 * $T)
    }

    Static [Single]InterpQuintic(
        [Single]$T
    ) {
        Return $T * $T * $T * ($T * ($T * 6 - 15) + 10)
    }

    Static [Single]CubicLerp(
        [Single]$A,
        [Single]$B,
        [Single]$C,
        [Single]$D,
        [Single]$T
    ) {
        [Single]$P = ($D - $C) - ($A - $B)

        Return $T * $T * $T * $P + $T * $T * (($A - $B) - $P) + $T * ($C - $A) + $B
    }

    Static [Int64]Hash(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed
    ) {
        [Int64]$Hash  = $ASeed -BXOR $XPrimed -BXOR $YPrimed
        $Hash        *= [FastNoiseLite]::HASH_MAGIC

        Return $Hash
    }

    Static [Int64]Hash(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Int64]$ZPrimed
    ) {
        [Int64]$Hash  = $ASeed -BXOR $XPrimed -BXOR $YPrimed -BXOR $ZPrimed
        $Hash        *= [FastNoiseLite]::HASH_MAGIC

        Return $Hash
    }

    Static [Single]ValCoord(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed
    ) {
        [Int64]$Hash  = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
        $Hash        *= $Hash
        $Hash         = $Hash -BXOR ($Hash -SHL 19) # ORIGINAL STATEMENT WAS hash ^= hash << 19;

        Return $Hash * (1 / [FastNoiseLite]::HASHCALC_MAGIC)
    }

    Static [Single]ValCoord(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Int64]$ZPrimed
    ) {
        [Int64]$Hash  = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
        $Hash        *= $Hash
        $Hash         = $Hash -BXOR ($Hash -SHL 19) # ORIGINAL STATEMENT WAS hash ^= hash << 19;

        Return $Hash * (1 / [FastNoiseLite]::HASHCALC_MAGIC)
    }

    Static [Single]GradCoord(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Single]$Xd,
        [Single]$Yd
    ) {
        [Int64]$Hash = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
        $Hash        = $Hash -BXOR ($Hash -SHR 15) # ORIGINAL STATEMENT WAS hash ^= hash >> 15;
        $Hash        = $Hash -BAND (127 -SHL 1) # ORIGINAL STATEMENT WAS  hash &= 127 << 1;

        [Single]$Xg = [FastNoiseLite]::GRADIENTS2D[$Hash]
        [Single]$Yg = [FastNoiseLite]::GRADIENTS2D[($Hash -BOR 1)]

        Return $Xd * $Xg + $Yd * $Yg
    }

    Static [Single]GradCoord(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Int64]$ZPrimed,
        [Single]$Xd,
        [Single]$Yd,
        [Single]$Zd
    ) {
        [Int64]$Hash = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
        $Hash        = $Hash -BXOR ($Hash -SHR 15) # ORIGINAL STATEMENT WAS hash ^= hash >> 15;
        $Hash        = $Hash -BAND (63 -SHL 2) # ORIGINAL STATEMENT WAS  hash &= 63 << 2;

        [Single]$Xg = [FastNoiseLite]::GRADIENTS3D[$Hash]
        [Single]$Yg = [FastNoiseLite]::GRADIENTS3D[($Hash -BOR 1)]
        [Single]$Zg = [FastNoiseLite]::GRADIENTS3D[($Hash -BOR 2)]

        Return $Xd * $Xg + $Yd * $Yg + $Zd * $Zg
    }

    ###########################################################################
    #
    # THE ORIGINAL SOURCE FOR THIS METHOD IS AS FOLLOWS:
    #
    #     private static void GradCoordOut(int seed, int xPrimed, int yPrimed, out Single xo, out Single yo)
    #     {
    #     int hash = Hash(seed, xPrimed, yPrimed) & (255 << 1);
    #
    #     xo = RandVecs2D[hash];
    #     yo = RandVecs2D[hash | 1];
    #     }
    #
    # USING REF ARGS IN LIEU OF OUT SHOULD BE SATISFACTORY HERE
    #
    ###########################################################################
    Static [Void]GradCoordOut(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Ref]$Xo,
        [Ref]$Yo
    ) {
        [Int64]$Hash = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed) -BAND (255 -SHL 1)

        $Xo.Value = [FastNoiseLite]::RANDVECS2D[$Hash]
        $Yo.Value = [FastNoiseLite]::RANDVECS2D[($Hash -BOR 1)]
    }

    Static [Void]GradCoordOut(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Int64]$ZPrimed,
        [Ref]$Xo,
        [Ref]$Yo,
        [Ref]$Zo
    ) {
        [Int64]$Hash = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed) -BAND (255 -SHL 2)

        $Xo.Value = [FastNoiseLite]::RANDVECS2D[$Hash]
        $Yo.Value = [FastNoiseLite]::RANDVECS2D[($Hash -BOR 1)]
        $Zo.Value = [FastNoiseLite]::RANDVECS2D[($Hash -BOR 2)]
    }

    Static [Void]GradCoordDual(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Single]$Xd,
        [Single]$Yd,
        [Ref]$Xo,
        [Ref]$Yo
    ) {
        [Int64]$Hash   = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
        [Int64]$Index1 = $Hash -BAND (127 -SHL 1)
        [Int64]$Index2 = ($Hash -SHR 7) -BAND (255 -SHL 1)
        [Single]$Xg    = [FastNoiseLite]::GRADIENTS2D[$Index1]
        [Single]$Yg    = [FastNoiseLite]::GRADIENTS2D[($Index1 -BOR 1)]
        [Single]$Xgo   = [FastNoiseLite]::RANDVECS2D[$Index2]
        [Single]$Ygo   = [FastNoiseLite]::RANDVECS2D[($Index2 -BOR 1)]
        [Single]$Value = $Xd * $Xg + $Yd * $Yg

        $Xo.Value = $Value * $Xgo
        $Yo.Value = $Value * $Ygo
    }

    Static [Void]GradCoordDual(
        [Int64]$ASeed,
        [Int64]$XPrimed,
        [Int64]$YPrimed,
        [Int64]$ZPrimed,
        [Single]$Xd,
        [Single]$Yd,
        [Single]$Zd,
        [Ref]$Xo,
        [Ref]$Yo,
        [Ref]$Zo
    ) {
        [Int64]$Hash   = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
        [Int64]$Index1 = $Hash -BAND (63 -SHL 2)
        [Int64]$Index2 = ($Hash -SHR 6) -BAND (255 -SHL 2)
        [Single]$Xg    = [FastNoiseLite]::GRADIENTS3D[$Index1]
        [Single]$Yg    = [FastNoiseLite]::GRADIENTS3D[($Index1 -BOR 1)]
        [Single]$Zg    = [FastNoiseLite]::GRADIENTS2D[($Index1 -BOR 2)]
        [Single]$Xgo   = [FastNoiseLite]::RANDVECS3D[$Index2]
        [Single]$Ygo   = [FastNoiseLite]::RANDVECS3D[($Index2 -BOR 1)]
        [Single]$Zgo   = [FastNoiseLite]::RANDVECS3D[($Index2 -BOR 2)]
        [Single]$Value = $Xd * $Xg + $Yd * $Yg + $Zd * $Zg

        $Xo.Value = $Value * $Xgo
        $Yo.Value = $Value * $Ygo
        $Zo.Value = $Value * $Zgo
    }

    [Void]SetNoiseType(
        [FnlNoiseType]$NoiseType
    ) {
        $this.NoiseType = $NoiseType
        $this.UpdateTransformType3D()
    }

    [Void]SetRotationType3D(
        [FnlRotationType3D]$RotationType3D
    ) {
        $this.RotationType3D = $RotationType3D
        $this.UpdateTransformType3D()
        $this.UpdateWarpTransformType3D()
    }

    [Void]SetFractalOctaves(
        [Int64]$Octaves
    ) {
        $this.Octaves = $Octaves
        $this.CalculateFractalBounding()
    }

    [Void]SetFractalGain(
        [Single]$Gain
    ) {
        $this.Gain = $Gain
        $this.CalculateFractalBounding()
    }

    [Void]SetDomainWarpType(
        [FnlDomainWarpType]$DomainWarpType
    ) {
        $this.DomainWarpType = $DomainWarpType
        $this.UpdateWarpTransformType3D()
    }

    [Single]GetNoise(
        [Single]$X,
        [Single]$Y
    ) {
        $this.TransformNoiseCoordinate(([Ref]$X), ([Ref]$Y))

        Switch($this.FractalType) {
            ([FnlFractalType]::FBm) {
                Return $this.GenFractalFBm($X, $Y)
            }

            ([FnlFractalType]::Ridged) {
                Return $this.GenFractalRidged($X, $Y)
            }

            ([FnlFractalType]::PingPong) {
                Return $this.GenFractalPingPong($X, $Y)
            }

            Default {
                Return $this.GenNoiseSingle($this.Seed, $X, $Y)
            }
        }

        # THIS CODE PATH ISN'T CONSIDERED IN THE ORIGINAL SOURCE, SO I'LL JUST INCLUDE THE DEFAULT CASE HERE
        # THIS IS MORE SO THE LINTER WILL SHUT UP, BUT JUSTIN CASE
        Return $this.GenNoiseSingle($this.Seed, $X, $Y)
    }

    [Single]GetNoise(
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        $this.TransformNoiseCoordinate(([Ref]$X), ([Ref]$Y), ([Ref]$Z))

        Switch($this.FractalType) {
            ([FnlFractalType]::FBm) {
                Return $this.GenFractalFBm($X, $Y, $Z)
            }

            ([FnlFractalType]::Ridged) {
                Return $this.GenFractalRidged($X, $Y, $Z)
            }

            ([FnlFractalType]::PingPong) {
                Return $this.GenFractalPingPong($X, $Y, $Z)
            }

            Default {
                Return $this.GenNoiseSingle($this.Seed, $X, $Y, $Z)
            }
        }

        # THIS CODE PATH ISN'T CONSIDERED IN THE ORIGINAL SOURCE, SO I'LL JUST INCLUDE THE DEFAULT CASE HERE
        # THIS IS MORE SO THE LINTER WILL SHUT UP, BUT JUSTIN CASE
        Return $this.GenNoiseSingle($this.Seed, $X, $Y, $Z)
    }

    [Void]DomainWarp(
        [Ref]$X,
        [Ref]$Y
    ) {
        Switch($this.FractalType) {
            ([FnlFractalType]::DomainWarpProgressive) {
                $this.DomainWarpFractalProgressive($X, $Y)

                Break
            }

            ([FnlFractalType]::DomainWarpIndependent) {
                $this.DomainWarpFractalIndependent($X, $Y)

                Break
            }

            Default {
                $this.DomainWarpSingle($X, $Y)

                Break
            }
        }

        $this.DomainWarpSingle($X, $Y)
    }

    [Void]DomainWarp(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        Switch($this.FractalType) {
            ([FnlFractalType]::DomainWarpProgressive) {
                $this.DomainWarpFractalProgressive($X, $Y, $Z)

                Break
            }

            ([FnlFractalType]::DomainWarpIndependent) {
                $this.DomainWarpFractalIndependent($X, $Y, $Z)

                Break
            }

            Default {
                $this.DomainWarpSingle($X, $Y, $Z)

                Break
            }
        }

        $this.DomainWarpSingle($X, $Y, $Z)
    }

    [Single]PingPong(
        [Single]$T
    ) {
        $T = $T - ([Int64]($T * 0.5)) * 2

        Return $T -LT 1 ? $T : 2 - $T
    }

    [Void]CalculateFractalBounding() {
        [Single]$LGain       = [FastNoiseLite]::FastAbs($this.Gain)
        [Single]$LAmp        = $LGain
        [Single]$LAmpFractal = 1

        For([Int64]$I = 1; $I -LT $this.Octaves; $I++) {
            $LAmpFractal += $LAmp
            $LAmp        *= $LGain
        }

        $this.FractalBounding = 1 / $LAmpFractal
    }

    [Single]GenNoiseSingle(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        Switch($this.NoiseType) {
            ([FnlNoiseType]::OpenSimplex2) {
                Return $this.SingleSimplex($ASeed, $X, $Y)
            }

            ([FnlNoiseType]::OpenSimplex2S) {
                Return $this.SingleOpenSimplex2S($ASeed, $X, $Y)
            }

            ([FnlNoiseType]::Cellular) {
                Return $this.SingleCellular($ASeed, $X, $Y)
            }

            ([FnlNoiseType]::Perlin) {
                Return $this.SinglePerlin($ASeed, $X, $Y)
            }

            ([FnlNoiseType]::ValueCubic) {
                Return $this.SingleValueCubic($ASeed, $X, $Y)
            }

            ([FnlNoiseType]::Value) {
                Return $this.SingleValue($ASeed, $X, $Y)
            }

            Default {
                Return 0
            }
        }

        Return 0
    }

    [Single]GenNoiseSingle(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        Switch($this.NoiseType) {
            ([FnlNoiseType]::OpenSimplex2) {
                Return $this.SingleSimplex($ASeed, $X, $Y, $Z)
            }

            ([FnlNoiseType]::OpenSimplex2S) {
                Return $this.SingleOpenSimplex2S($ASeed, $X, $Y, $Z)
            }

            ([FnlNoiseType]::Cellular) {
                Return $this.SingleCellular($ASeed, $X, $Y, $Z)
            }

            ([FnlNoiseType]::Perlin) {
                Return $this.SinglePerlin($ASeed, $X, $Y, $Z)
            }

            ([FnlNoiseType]::ValueCubic) {
                Return $this.SingleValueCubic($ASeed, $X, $Y, $Z)
            }

            ([FnlNoiseType]::Value) {
                Return $this.SingleValue($ASeed, $X, $Y, $Z)
            }

            Default {
                Return 0
            }
        }

        Return 0
    }

    [Void]TransformNoiseCoordinate(
        [Ref]$X,
        [Ref]$Y
    ) {
        $X.Value *= $this.Frequency
        $Y.Value *= $this.Frequency

        Switch($this.NoiseType) {
            ($_ -EQ [FnlNoiseType]::OpenSimplex2 -OR $_ -EQ [FnlNoiseType]::OpenSimplex2S) {
                [Single]$F2 = 0.5 * ([FastNoiseLite]::SQRT3 - 1)
                [Single]$T  = ($X.Value + $Y.Value) * $F2

                $X.Value += $T
                $Y.Value += $T

                Break
            }

            Default {
                Break
            }
        }

        Return
    }

    [Void]TransformNoiseCoordinate(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        $X.Value *= $this.Frequency
        $Y.Value *= $this.Frequency
        $Z.Value *= $this.Frequency

        Switch($this.TransformType3D) {
            ([FnlTransformType3D]::ImproveXYPlanes) {
                [Single]$Xy = $X.Value + $Y.Value
                [Single]$S2 = $Xy * -[FastNoiseLite]::PLANARIMPROVEA_MAGIC

                $Z.Value *= [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC
                $X.Value += $S2 - $Z.Value
                $Y.Value += $S2 - $Z.Value
                $Z.Value += $Xy * [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC

                Break
            }

            ([FnlTransformType3D]::ImproveXZPlanes) {
                [Single]$Xz = $X.Value + $Z.Value
                [Single]$S2 = $Xz * -[FastNoiseLite]::PLANARIMPROVEA_MAGIC

                $Y.Value *= [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC
                $X.Value += $S2 - $Z.Value
                $Y.Value += $S2 - $Z.Value
                $Z.Value += $Xz * [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC

                Break
            }

            ([FnlTransformType3D]::DefaultOpenSimplex2) {
                [Single]$R = ($X.Value + $Y.Value + $Z.Value) * [FastNoiseLite]::A2DIV3

                $X.Value = $R - $X.Value
                $Y.Value = $R - $Y.Value
                $Z.Value = $R - $Z.Value

                Break
            }

            Default {
                Break
            }
        }

        Return
    }

    [Void]UpdateTransformType3D() {
        Switch($this.RotationType3D) {
            ([FnlRotationType3D]::ImproveXYPlanes) {
                $this.TransformType3D = [FnlTransformType3D]::ImproveXYPlanes

                Break
            }

            ([FnlRotationType3D]::ImproveXZPlanes) {
                $this.TransformType3D = [FnlTransformType3D]::ImproveXZPlanes

                Break
            }

            Default {
                Switch($this.NoiseType) {
                    ($_ -EQ [FnlNoiseType]::OpenSimplex2 -OR $_ -EQ [FnlNoiseType]::OpenSimplex2S) {
                        $this.TransformType3D = [FnlTransformType3D]::DefaultOpenSimplex2

                        Break
                    }

                    Default {
                        $this.TransformType3D = [FnlTransformType3D]::None

                        Break
                    }
                }

                Break
            }
        }

        Return
    }

    [Void]TransformDomainWarpCoordinate(
        [Ref]$X,
        [Ref]$Y
    ) {
        Switch($this.DomainWarpType) {
            ($_ -EQ [FnlDomainWarpType]::OpenSimplex2 -OR $_ -EQ [FnlDomainWarpType]::OpenSimplex2Reduced) {
                [Single]$F2 = 0.5 * ([FastNoiseLite]::SQRT3 - 1)
                [Single]$T  = ($X.Value + $Y.Value) * $F2

                $X.Value += $T
                $Y.Value += $T

                Break
            }

            Default {
                Break
            }
        }

        Return
    }

    [Void]TransformDomainWarpCoordinate(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        Switch($this.WarpTransformType3D) {
            ([FnlTransformType3D]::ImproveXYPlanes) {
                [Single]$Xy = $X.Value + $Y.Value
                [Single]$S2 = $Xy * -[FastNoiseLite]::PLANARIMPROVEA_MAGIC

                $Z.Value *= [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC
                $X.Value += $S2 - $Z.Value
                $Y.Value += $S2 - $Z.Value
                $Z.Value += $Xy * [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC

                Break
            }

            ([FnlTransformType3D]::ImproveXZPlanes) {
                [Single]$Xz = $X.Value + $Z.Value
                [Single]$S2 = $Xz * -[FastNoiseLite]::PLANARIMPROVEA_MAGIC

                $Y.Value *= [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC
                $X.Value += $S2 - $Y.Value
                $Z.Value += $S2 - $Y.Value
                $Y.Value += $Xz * [FastNoiseLite]::PLANARIMPROVEZSCALE_MAGIC

                Break
            }

            ([FnlTransformType3D]::DefaultOpenSimplex2) {
                [Single]$R = ($X.Value + $Y.Value + $Z.Value) * [FastNoiseLite]::A2DIV3

                $X.Value = $R - $X.Value
                $Y.Value = $R - $Y.Value
                $Z.Value = $R - $Z.Value

                Break
            }

            Default {
                Break
            }
        }

        Return
    }

    [Void]UpdateWarpTransformType3D() {
        Switch($this.RotationType3D) {
            ([FnlRotationType3D]::ImproveXYPlanes) {
                $this.WarpTransformType3D = [FnlTransformType3D]::ImproveXYPlanes

                Break
            }

            ([FnlRotationType3D]::ImproveXZPlanes) {
                $this.WarpTransformType3D = [FnlTransformType3D]::ImproveXZPlanes

                Break
            }

            Default {
                Switch($this.DomainWarpType) {
                    ($_ -EQ [FnlDomainWarpType]::OpenSimplex2 -OR $_ -EQ [FnlDomainWarpType]::OpenSimplex2Reduced) {
                        $this.WarpTransformType3D = [FnlTransformType3D]::DefaultOpenSimplex2

                        Break
                    }

                    Default {
                        $this.WarpTransformType3D = [FnlTransformType3D]::None

                        Break
                    }
                }

                Break
            }
        }

        Return
    }

    [Single]GenFractalFBm(
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = $this.GenNoiseSingle($ASeed++, $X, $Y)

            $Sum += $Noise * $Amp
            $Amp *= $this.Lerp(1, [FastNoiseLite]::FastMin($Noise + 1, 2) * 0.5, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]GenFractalFBm(
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = $this.GenNoiseSingle($ASeed++, $X, $Y, $Z)

            $Sum += $Noise * $Amp
            $Amp *= $this.Lerp(1, [FastNoiseLite]::FastMin($Noise + 1, 2) * 0.5, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Z   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]GenFractalRidged(
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = [FastNoiseLite]::FastAbs($this.GenNoiseSingle($ASeed++, $X, $Y))

            $Sum += ($Noise * -2 + 1) * $Amp
            $Amp *= $this.Lerp(1, 1 - $Noise, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]GenFractalRidged(
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = [FastNoiseLite]::FastAbs($this.GenNoiseSingle($ASeed++, $X, $Y, $Z))

            $Sum += ($Noise * -2 + 1) * $Amp
            $Amp *= $this.Lerp(1, 1 - $Noise, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Z   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]GenFractalPingPong(
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = $this.PingPong(($this.GenNoiseSingle($ASeed++, $X, $Y) + 1) * $this.PingPongStrength)

            $Sum += ($Noise - 0.5) * 2 * $Amp
            $Amp *= $this.Lerp(1, $Noise, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]GenFractalPingPong(
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Sum  = 0
        [Single]$Amp  = $this.FractalBounding

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Noise = $this.PingPong(($this.GenNoiseSingle($ASeed++, $X, $Y, $Z) + 1) * $this.PingPongStrength)

            $Sum += ($Noise - 0.5) * 2 * $Amp
            $Amp *= $this.Lerp(1, $Noise, $this.WeightedStrength)
            $X   *= $this.Lacunarity
            $Y   *= $this.Lacunarity
            $Z   *= $this.Lacunarity
            $Amp *= $this.Gain
        }

        Return $Sum
    }

    [Single]SingleSimplex(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Single]$G2   = (3 - [FastNoiseLite]::SQRT3) / 6
        [Single]$G2m1 = $G2 - 1
        [Single]$G2a1 = 1 - 2 * $G2
        [Single]$G2a2 = 2 * $G2m1
        [Int64]$I     = [FastNoiseLite]::FastFloor($X)
        [Int64]$J     = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xi   = ([Single]($X - $I))
        [Single]$Yi   = ([Single]($Y - $J))
        [Single]$T    = ($Xi + $Yi) * $G2
        [Single]$X0   = $Xi - $T
        [Single]$Y0   = $Yi - $T
        [Single]$N0   = 0
        [Single]$N1   = 0
        [Single]$N2   = 0

        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY

        [Single]$A  = 0.5 - $X0 * $X0 - $Y0 * $Y0

        If($A -LE 0) {
            $N0 = 0
        } Else {
            $N0 = $A * $A * $A * $A * [FastNoiseLite]::GradCoord($ASeed, $I, $J, $X0, $Y0)
        }

        [Single]$C  = ([Single](2 * $G2a1 * (1 / $G2 - 2)) * $T + ([Single](-2 * $G2a1 * $G2a1) + $A))

        If($C -LE 0) {
            $N2 = 0
        } Else {
            [Single]$X2 = $X0 + $G2a2
            [Single]$Y2 = $Y0 + $G2a2

            $N2 = $C * $C * $C * $C * [FastNoiseLite]::GradCoord($ASeed, $I + [FastNoiseLite]::PRIMEX, $J + [FastNoiseLite]::PRIMEY, $X2, $Y2)
        }

        If($Y0 -GT $X0) {
            [Single]$X1 = $X0 + $G2
            [Single]$Y1 = $Y0 + $G2m1
            [Single]$B  = 0.5 - $X1 * $X1 - $Y1 * $Y1

            If($B -LE 0) {
                $N1 = 0
            } Else {
                $N1 = $B * $B * $B * $B * [FastNoiseLite]::GradCoord($ASeed, $I, $J + [FastNoiseLite]::PRIMEY, $X1, $Y1)
            }
        } Else {
            [Single]$X1 = $X0 + $G2m1
            [Single]$Y1 = $Y0 + $G2
            [Single]$B  = 0.5 - $X1 * $X1 - $Y1 * $Y1

            If($B -LE 0) {
                $N1 = 0
            } Else {
                $N1 = $B * $B * $B * $B * [FastNoiseLite]::GradCoord($ASeed, $I + [FastNoiseLite]::PRIMEX, $J, $X1, $Y1)
            }
        }

        Return ($N0 + $N1 + $N2) * 99.83685446303647
    }

    [Single]SingleOpenSimplex2(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$I      = [FastNoiseLite]::FastRound($X)
        [Int64]$J      = [FastNoiseLite]::FastRound($Y)
        [Int64]$K      = [FastNoiseLite]::FastRound($Z)
        [Single]$X0    = ([Single]($X - $I))
        [Single]$Y0    = ([Single]($Y - $J))
        [Single]$Z0    = ([Single]($Z - $K))
        [Int64]$XNSign = ([Int64](-1 - $X0) -BOR 1)
        [Int64]$YNSign = ([Int64](-1 - $Y0) -BOR 1)
        [Int64]$ZNSign = ([Int64](-1 - $Z0) -BOR 1)
        [Single]$Ax0   = $XNSign * -$X0
        [Single]$Ay0   = $YNSign * -$Y0
        [Single]$Az0   = $ZNSign * -$Z0
    
        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY
        $K *= [FastNoiseLite]::PRIMEZ
    
        [Single]$Value = 0
        [Single]$A     = (0.6 - $X0 * $X0) - ($Y0 * $Y0 + $Z0 * $Z0)
    
        For([Int64]$L = 0; ; $L++) {
            If($A -GT 0) {
                $Value += $A * $A * $A * $A * [FastNoiseLite]::GradCoord($ASeed, $I, $J, $K, $X0, $Y0, $Z0)
            }

            If($Ax0 -GE $Ay0 -AND $Ax0 -GE $Az0) {
                [Single]$B  = $A + $Ax0 + $Ax0

                If($B -GT 1) {
                    $B     -= 1
                    $Value += $B * $B * $B * $B * [FastNoiseLite]::GradCoord($ASeed, $I - $XNSign * [FastNoiseLite]::PRIMEX, $J, $K, $X0 + $XNSign, $Y0, $Z0)
                }
            } Elseif($Ay0 -GT $Ax0 -AND $Ay0 -GE $Az0) {
                [Single]$B  = $A + $Ay0 + $Ay0

                If($B -GT 1) {
                    $B     -= 1
                    $Value += $B * $B * $B * $B * [FastNoiseLite]::GradCoord($ASeed, $I, $J - $YNSign * [FastNoiseLite]::PRIMEY, $K, $X0, $Y0 + $YNSign, $Z0)
                }
            } Else {
                [Single]$B  = $A + $Az0 + $Az0

                If($B -GT 1) {
                    $B     -= 1
                    $Value += $B * $B * $B * $B * [FastNoiseLite]::GradCoord($ASeed, $I, $J, $K - $ZNSign * [FastNoiseLite]::PRIMEZ, $X0, $Y0, $Z0 + $ZNSign)
                }
            }

            If($L == 1) {
                Break
            }

            $Ax0     = 0.5 - $Ax0
            $Ay0     = 0.5 - $Ay0
            $Az0     = 0.5 - $Az0
            $X0      = $XNSign * $Ax0
            $Y0      = $YNSign * $Ay0
            $Z0      = $ZNSign * $Az0
            $A      += (0.75 - $Ax0) - ($Ay0 + $Az0)
            $I      += ($XNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEX
            $J      += ($YNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEY
            $K      += ($ZNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEZ
            $XNSign  = -$XNSign
            $YNSign  = -$YNSign
            $ZNSign  = -$ZNSign
            $ASeed   = -BNOT $ASeed
        }

        Return $Value * [FastNoiseLite]::SIMPLEXVALMODA_MAGIC
    }

    [Single]SingleOpenSimplex2S(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Single]$G2   = (3 - [FastNoiseLite]::SQRT3) / 6
        [Single]$G2m1 = $G2 - 1
        [Single]$G2a1 = 1 - 2 * $G2
        [Int64]$I     = [FastNoiseLite]::FastFloor($X)
        [Int64]$J     = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xi   = ([Single]($X - $I))
        [Single]$Yi   = ([Single]($Y - $J))

        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY

        [Int64]$I1     = $I + [FastNoiseLite]::PRIMEX
        [Int64]$J1     = $J + [FastNoiseLite]::PRIMEY
        [Single]$T     = ($Xi + $Yi) * $G2
        [Single]$X0    = $Xi - $T
        [Single]$Y0    = $Yi - $T
        [Single]$A0    = [FastNoiseLite]::A2DIV3 - $X0 * $X0 - $Y0 * $Y0
        [Single]$Value = $A0 * $A0 * $A0 * $A0 * [FastNoiseLite]::GradCoord($ASeed, $I, $J, $X0, $Y0)
        [Single]$A1    = ([Single](2 * $G2a1 * (1 / $G2 - 2)) * $T + ([Single](-2 * $G2a1 * $G2a1) + $A0))
        [Single]$X1    = $X0 - $G2a1
        [Single]$Y1    = $Y0 - $G2a1

        $Value += $A1 * $A1 * $A1 * $A1 * [FastNoiseLite]::GradCoord($ASeed, $I1, $J1, $X1, $Y1)

        [Single]$Xmyi = $Xi - $Yi

        If($T -GT $G2) {
            If($Xi + $Xmyi -GT 1) {
                [Single]$X2  = $X0 + (3 * $G2 - 2)
                [Single]$Y2  = $Y0 + (3 * $G2 - 1)
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I + ([FastNoiseLite]::PRIMEX -SHL 1), $J + [FastNoiseLite]::PRIMEY, $X2, $Y2)
                }
            } Else {
                [Single]$X2  = $X0 + $G2
                [Single]$Y2  = $Y0 + $G2m1
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I, $J + [FastNoiseLite]::PRIMEY, $X2, $Y2)
                }
            }

            If($Yi - $Xmyi -GT 1) {
                [Single]$X3  = $X0 + $G2m1
                [Single]$Y3  = $Y0 + $G2
                [Single]$A3  = [FastNoiseLite]::A2DIV3 - $X3 * $X3 - $Y3 * $Y3

                If($A3 -GT 0) {
                    $Value += $A3 * $A3 * $A3 * $A3 * [FastNoiseLite]::GradCoord($ASeed, $I + [FastNoiseLite]::PRIMEX, $J, $X3, $Y3)
                }
            }
        } Else {
            If($Xi + $Xmyi -LT 0) {
                [Single]$X2  = $X0 + $G2m1
                [Single]$Y2  = $Y0 - $G2
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I - [FastNoiseLite]::PRIMEX, $J, $X2, $Y2)
                }
            } Else {
                [Single]$X2  = $X0 + $G2m1
                [Single]$Y2  = $Y0 - $G2
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I + [FastNoiseLite]::PRIMEX, $J, $X2, $Y2)
                }
            }

            If($Yi -LT $Xmyi) {
                [Single]$X2  = $X0 - $G2
                [Single]$Y2  = $Y0 - $G2m1
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I, $J - [FastNoiseLite]::PRIMEY, $X2, $Y2)
                }
            } Else {
                [Single]$X2  = $X0 + $G2
                [Single]$Y2  = $Y0 + $G2m1
                [Single]$A2  = [FastNoiseLite]::A2DIV3 - $X2 * $X2 - $Y2 * $Y2

                If($A2 -GT 0) {
                    $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord($ASeed, $I, $J + [FastNoiseLite]::PRIMEY, $X2, $Y2)
                }
            }
        }

        Return $Value * 18.24196194486065
    }

    [Single]SingleOpenSimplex2S(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$I   = [FastNoiseLite]::FastFloor($X)
        [Int64]$J   = [FastNoiseLite]::FastFloor($Y)
        [Int64]$K   = [FastNoiseLite]::FastFloor($Z)
        [Single]$Xi = ([Single]($X - $I))
        [Single]$Yi = ([Single]($Y - $J))
        [Single]$Zi = ([Single]($Z - $K))

        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY
        $K *= [FastNoiseLite]::PRIMEZ

        [Int64]$Seed2  = $ASeed + [FastNoiseLite]::SEEDADD_MAGIC
        [Int64]$XNMask = ([Int64](0.5 - $Xi))
        [Int64]$YNMask = ([Int64](0.5 - $Yi))
        [Int64]$ZNMask = ([Int64](0.5 - $Zi))
        [Single]$X0    = $Xi + $XNMask
        [Single]$Y0    = $Yi + $YNMask
        [Single]$Z0    = $Zi + $ZNMask
        [Single]$A0    = 0.75 - $X0 * $X0 - $Y0 * $Y0 - $Z0 * $Z0
        [Single]$Value = $A0 * $A0 * $A0 * $A0 * [FastNoiseLite]::GradCoord(
            $ASeed,
            $I + ($XNMask -BAND [FastNoiseLite]::PRIMEX),
            $J + ($YNMask -BAND [FastNoiseLite]::PRIMEY),
            $K + ($ZNMask -BAND [FastNoiseLite]::PRIMEZ),
            $X0, $Y0, $Z0
        )

        [Single]$X1   = $Xi - 0.5
        [Single]$Y1   = $Yi - 0.5
        [Single]$Z1   = $Zi - 0.5
        [Single]$A1   = 0.75 - $X1 * $X1 - $Y1 * $Y1 - $Z1 * $Z1
        $Value       += $A1 * $A1 * $A1 * $A1 * [FastNoiseLite]::GradCoord(
            $Seed2,
            $I + [FastNoiseLite]::PRIMEX,
            $J + [FastNoiseLite]::PRIMEY,
            $K + [FastNoiseLite]::PRIMEZ,
            $X1, $Y1, $Z1
        )

        [Single]$XAFlipMask0 = (($XNMask -BOR 1) -SHL 1) * $X1
        [Single]$YAFlipMask0 = (($YNMask -BOR 1) -SHL 1) * $Y1
        [Single]$ZAFlipMask0 = (($ZNMask -BOR 1) -SHL 1) * $Z1
        [Single]$XAFlipMask1 = (-2 - ($XNMask -SHL 2)) * $X1 - 1
        [Single]$YAFlipMask1 = (-2 - ($YNMask -SHL 2)) * $Y1 - 1
        [Single]$ZAFlipMask1 = (-2 - ($ZNMask -SHL 2)) * $Z1 - 1
        [Boolean]$Skip5      = $false
        [Single]$A2          = $XAFlipMask0 + $A0

        If($A2 -GT 0) {
            [Single]$X2 = $X0 - ($XNMask -BOR 1)
            [Single]$Y2 = $Y0
            [Single]$Z2 = $Z0

            $Value += $A2 * $A2 * $A2 * $A2 * [FastNoiseLite]::GradCoord(
                $ASeed,
                $I + (-BNOT $XNMask -BAND [FastNoiseLite]::PRIMEX),
                $J + ($YNMask -BAND [FastNoiseLite]::PRIMEY),
                $K + ($ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                $X2, $Y2, $Z2
            )
        } Else {
            [Single]$A3  = $YAFlipMask0 + $ZAFlipMask0 + $A0

            If($A3 -GT 0) {
                [Single]$X3 = $X0
                [Single]$Y3 = $Y0 - ($YNMask -BOR 1)
                [Single]$Z3 = $Z0 - ($ZNMask -BOR 1)

                $Value += $A3 * $A3 * $A3 * $A3 * [FastNoiseLite]::GradCoord(
                    $ASeed,
                    $I + ($XNMask -BAND [FastNoiseLite]::PRIMEX),
                    $J + (-BNOT $YNMask -BAND [FastNoiseLite]::PRIMEY),
                    $K + (-BNOT $ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                    $X3, $Y3, $Z3
                )
            }

            [Single]$A4  = $XAFlipMask1 + $A1

            If($A4 -GT 0) {
                [Single]$X4 = ($XNMask -BOR 1) + $X1
                [Single]$Y4 = $Y1
                [Single]$Z4 = $Z1

                $Value += $A4 * $A4 * $A4 * $A4 * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + ($XNMask -BAND [FastNoiseLite]::APRIMEXMULT2),
                    $J + [FastNoiseLite]::PRIMEY,
                    $K + [FastNoiseLite]::PRIMEZ,
                    $X4, $Y4, $Z4
                )
                $Skip5 = $true
            }
        }

        [Boolean]$Skip9 = $false
        [Single]$A6     = $YAFlipMask0 + $A0

        If($A6 -GT 0) {
            [Single]$X6 = $X0
            [Single]$Y6 = $Y0 - ($YNMask -BOR 1)
            [Single]$Z6 = $Z0

            $Value += $A6 * $A6 * $A6 * $A6 * [FastNoiseLite]::GradCoord(
                $ASeed,
                $I + ($XNMask -BAND [FastNoiseLite]::PRIMEX),
                $J + (-BNOT $YNMask -BAND [FastNoiseLite]::PRIMEY),
                $K + ($ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                $X6, $Y6, $Z6
            )
        } Else {
            [Single]$A7  = $XAFlipMask0 + $ZAFlipMask0 + $A0

            If($A7 -GT 0) {
                [Single]$X7 = $X0 - ($XNMask -BOR 1)
                [Single]$Y7 = $Y0
                [Single]$Z7 = $Z0 - ($ZNMask -BOR 1)

                $Value += $A7 * $A7 * $A7 * $A7 * [FastNoiseLite]::GradCoord(
                    $ASeed,
                    $I + (-BNOT $XNMask -BAND [FastNoiseLite]::PRIMEX),
                    $J + ($YNMask -BAND [FastNoiseLite]::PRIMEY),
                    $K + (-BNOT $ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                    $X7, $Y7, $Z7
                )
            }

            [Single]$A8  = $YAFlipMask1 + $A1

            If($A8 -GT 0) {
                [Single]$X8 = $X1
                [Single]$Y8 = ($YNMask -BOR 1) + $Y1
                [Single]$Z8 = $Z1

                $Value += $A8 * $A8 * $A8 * $A8 * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + [FastNoiseLite]::PRIMEX,
                    $J + ($YNMask -BAND ([FastNoiseLite]::PRIMEY -SHL 1)),
                    $K + [FastNoiseLite]::PRIMEZ,
                    $X8, $Y8, $Z8
                )
                $Skip9 = $true
            }
        }

        [Boolean]$SkipD = $false
        [Single]$Aa     = $ZAFlipMask0 + $A0

        If($Aa -GT 0) {
            [Single]$Xa = $X0
            [Single]$Ya = $Y0
            [Single]$Za = $Z0 - ($ZNMask -BOR 1)

            $Value += $Aa * $Aa * $Aa * $Aa * [FastNoiseLite]::GradCoord(
                $ASeed,
                $I + ($XNMask -BAND [FastNoiseLite]::PRIMEX),
                $J + ($YNMask -BAND [FastNoiseLite]::PRIMEY),
                $K + (-BNOT $ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                $Xa, $Ya, $Za
            )
        } Else {
            [Single]$Ab  = $XAFlipMask0 + $YAFlipMask0 + $A0

            If($Ab -GT 0) {
                [Single]$Xb = $X0 - ($XNMask -BOR 1)
                [Single]$Yb = $Y0 - ($YNMask -BOR 1)
                [Single]$Zb = $Z0

                $Value += $Ab * $Ab * $Ab * $Ab * [FastNoiseLite]::GradCoord(
                    $ASeed,
                    $I + (-BNOT $XNMask -BAND [FastNoiseLite]::PRIMEX),
                    $J + (-BNOT $YNMask -BAND [FastNoiseLite]::PRIMEY),
                    $K + ($ZNMask -BAND [FastNoiseLite]::PRIMEZ),
                    $Xb, $Yb, $Zb
                )
            }

            [Single]$Ac  = $ZAFlipMask1 + $A1

            If($Ac -GT 0) {
                [Single]$Xc = $X1
                [Single]$Yc = $Y1
                [Single]$Zc = ($ZNMask -BOR 1) + $Z1

                $Value += $Ac * $Ac * $Ac * $Ac * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + [FastNoiseLite]::PRIMEX,
                    $J + [FastNoiseLite]::PRIMEY,
                    $K + ($ZNMask -BAND ([FastNoiseLite]::PRIMEZ -SHL 1)),
                    $Xc, $Yc, $Zc
                )
                $SkipD = $true
            }
        }

        If(-NOT $Skip5) {
            [Single]$A5  = $YAFlipMask1 + $ZAFlipMask1 + $A1

            If($A5 -GT 0) {
                [Single]$X5 = $X1
                [Single]$Y5 = ($YNMask -BOR 1) + $Y1
                [Single]$Z5 = ($ZNMask -BOR 1) + $Z1

                $Value += $A5 * $A5 * $A5 * $A5 * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + [FastNoiseLite]::PRIMEX,
                    $J + ($YNMask -BAND ([FastNoiseLite]::PRIMEY -SHL 1)),
                    $K + ($ZNMask -BAND ([FastNoiseLite]::PRIMEZ -SHL 1)),
                    $X5, $Y5, $Z5
                )
            }
        }

        If(-NOT $Skip9) {
            [Single]$A9  = $XAFlipMask1 + $ZAFlipMask1 + $A1

            If($A9 -GT 0) {
                [Single]$X9 = ($XNMask -BOR 1) + $X1
                [Single]$Y9 = $Y1
                [Single]$Z9 = ($ZNMask -BOR 1) + $Z1

                $Value += $A9 * $A9 * $A9 * $A9 * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + ($XNMask -BAND [FastNoiseLite]::APRIMEXMULT2),
                    $J + [FastNoiseLite]::PRIMEY,
                    $K + ($ZNMask -BAND ([FastNoiseLite]::PRIMEZ -SHL 1)),
                    $X9, $Y9, $Z9
                )
            }
        }

        If(-NOT $SkipD) {
            [Single]$Ad  = $XAFlipMask1 + $YAFlipMask1 + $A1

            If($Ad -GT 0) {
                [Single]$Xd = ($XNMask -BOR 1) + $X1
                [Single]$Yd = ($YNMask -BOR 1) + $Y1
                [Single]$Zd = $Z1

                $Value += $Ad * $Ad * $Ad * $Ad * [FastNoiseLite]::GradCoord(
                    $Seed2,
                    $I + ($XNMask -BAND ([FastNoiseLite]::PRIMEX -SHL 1)),
                    $J + ($YNMask -BAND ([FastNoiseLite]::PRIMEY -SHL 1)),
                    $K + [FastNoiseLite]::PRIMEZ,
                    $Xd, $Yd, $Zd
                )
            }
        }

        Return $Value * 9.046026385208288
    }

    [Single]SingleCellular(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$Xr              = [FastNoiseLite]::FastRound($X)
        [Int64]$Yr              = [FastNoiseLite]::FastRound($Y)
        [Int64]$ClosestHash     = 0
        [Int64]$XPrimed         = ($Xr - 1) * [FastNoiseLite]::PRIMEX
        [Int64]$YPrimedBase     = ($Yr - 1) * [FastNoiseLite]::PRIMEY
        [Single]$Distance0      = [Single]::MaxValue
        [Single]$Distance1      = [Single]::MaxValue
        [Single]$CellularJitter = 0.43701595 * $this.CellularJitterModifier

        Switch($this.CellularDistanceFunction) {
            { $_ -EQ [FnlCellularDistanceFunction]::Euclidean -OR $_ -EQ [FnlCellularDistanceFunction]::EuclideanSq } {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr + 1; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr - 1; $Yi++) {
                        [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
                        [Int64]$Idx          = $AHash -BAND (255 -SHL 1)
                        [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS2D[$Idx] * $CellularJitter)
                        [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS2D[$Idx -BOR 1] * $CellularJitter)
                        [Single]$NewDistance = $VecX * $VecX + $VecY * $VecY

                        $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                        If($NewDistance -LT $Distance0) {
                            $Distance0   = $NewDistance
                            $ClosestHash = $AHash
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            ([FnlCellularDistanceFunction]::Manhattan) {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr + 1; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr + 1; $Yi++) {
                        [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
                        [Int64]$Idx          = $AHash -BAND (255 -SHL 1)
                        [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS2D[$Idx] * $CellularJitter)
                        [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS2D[$Idx -BOR 1] * $CellularJitter)
                        [Single]$NewDistance = [FastNoiseLite]::FastAbs($VecX) + [FastNoiseLite]::FastAbs($VecY)

                        $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                        If($NewDistance -LT $Distance0) {
                            $Distance0   = $NewDistance
                            $ClosestHash = $AHash
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            ([FnlCellularDistanceFunction]::Hybrid) {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr + 1; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr + 1; $Yi++) {
                        [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
                        [Int64]$Idx          = $AHash -BAND (255 -SHL 1)
                        [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS2D[$Idx] * $CellularJitter)
                        [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS2D[$Idx -BOR 1] * $CellularJitter)
                        [Single]$NewDistance = ([FastNoiseLite]::FastAbs($VecX) + [FastNoiseLite]::FastAbs($VecY)) + ($VecX * $VecX + $VecY * $VecY)

                        $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance0))
                        If($NewDIstance -LT $Distance0) {
                            $Distance0   = $NewDistance
                            $ClosestHash = $AHash
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            Default { # SAME AS FIRST CASE
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr + 1; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr - 1; $Yi++) {
                        [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed)
                        [Int64]$Idx          = $AHash -BAND (255 -SHL 1)
                        [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS2D[$Idx] * $CellularJitter)
                        [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS2D[$Idx -BOR 1] * $CellularJitter)
                        [Single]$NewDistance = $VecX * $VecX + $VecY * $VecY

                        $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                        If($NewDistance -LT $Distance0) {
                            $Distance0   = $NewDistance
                            $ClosestHash = $AHash
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }
        }

        If($this.CellularDistanceFunction -EQ [FnlCellularDistanceFunction]::Euclidean -AND $this.CellularReturnType -GE [FnlCellularReturnType]::Distance) {
            $Distance0 = [FastNoiseLite]::FastSqrt($Distance0)

            If($this.CellularReturnType -GE [FnlCellularReturnType]::Distance2) {
                $Distance1 = [FastNoiseLite]::FastSqrt($Distance1)
            }
        }

        Switch($this.CellularReturnType) {
            ([FnlCellularReturnType]::CellValue) {
                Return $ClosestHash * (1 / [FastNoiseLite]::HASHCALC_MAGIC)
            }

            ([FnlCellularReturnType]::Distance) {
                Return $Distance0 - 1
            }

            ([FnlCellularReturnType]::Distance2) {
                Return $Distance1 - 1
            }

            ([FnlCellularReturnType]::Distance2Add) {
                Return ($Distance1 + $Distance0) * 0.5 - 1
            }

            ([FnlCellularReturnType]::Distance2Sub) {
                Return $Distance1 - $Distance0 - 1
            }

            ([FnlCellularReturnType]::Distance2Mul) {
                Return $Distance1 * $Distance0 * 0.5 - 1
            }

            ([FnlCellularReturnType]::Distance2Div) {
                Return $Distance0 / $Distance1 - 1
            }

            Default {
                Return 0
            }
        }

        Return 0
    }

    [Single]SingleCellular(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$Xr              = [FastNoiseLite]::FastRound($X)
        [Int64]$Yr              = [FastNoiseLite]::FastRound($Y)
        [Int64]$Zr              = [FastNoiseLite]::FastRound($Z)
        [Int64]$ClosestHash     = 0
        [Single]$Distance0      = [Single]::MaxValue
        [Single]$Distance1      = [Single]::MaxValue
        [Single]$CellularJitter = 0.39614353 * $this.CellularJitterModifier
        [Int64]$XPrimed         = ($Xr - 1) * [FastNoiseLite]::PRIMEX
        [Int64]$YPrimedBase     = ($Yr - 1) * [FastNoiseLite]::PRIMEY
        [Int64]$ZPrimedBase     = ($Zr - 1) * [FastNoiseLite]::PRIMEZ

        Switch($this.CellularDistanceFunction) {
            { $_ -EQ [FnlCellularDistanceFunction]::Euclidean -OR $_ -EQ [FnlCellularDistanceFunction]::EuclideanSq } {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr; $Yi++) {
                        [Int64]$ZPrimed = $ZPrimedBase

                        For([Int64]$Zi = $Zr - 1; $Zi -LE $Zr; $Zi++) {
                            [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
                            [Int64]$Idx          = $AHash -BAND (255 -SHL 2)
                            [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS3D[$Idx] * $CellularJitter)
                            [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 1] * $CellularJitter)
                            [Single]$VecZ        = ([Single]($Zi - $Z) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 2] * $CellularJitter)
                            [Single]$NewDistance = $VecX * $VecX + $VecY * $VecY + $VecZ * $VecZ

                            $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                            If($NewDistance -LT $Distance0) {
                                $Distance0   = $NewDistance
                                $ClosestHash = $AHash
                            }

                            $ZPrimed += [FastNoiseLite]::PRIMEZ
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            ([FnlCellularDistanceFunction]::Manhattan) {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr; $Yi++) {
                        [Int64]$ZPrimed = $ZPrimedBase

                        For([Int64]$Zi = $Zr - 1; $Zi -LE $Zr + 1; $Zi++) {
                            [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
                            [Int64]$Idx          = $AHash -BAND (255 -SHL 2)
                            [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS3D[$Idx] * $CellularJitter)
                            [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 1] * $CellularJitter)
                            [Single]$VecZ        = ([Single]($Zi - $Z) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 2] * $CellularJitter)
                            [Single]$NewDistance = [FastNoiseLite]::FastAbs($VecX) + [FastNoiseLite]::FastAbs($VecY) + [FastNoiseLite]::FastAbs($VecZ)

                            $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                            If($NewDistance -LT $Distance0) {
                                $Distance0   = $NewDistance
                                $ClosestHash = $AHash
                            }

                            $ZPrimed += [FastNoiseLite]::PRIMEZ
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            ([FnlCellularDistanceFunction]::Hybrid) {
                For([Int64]$Xi = $Xr - 1; $Xi -LE $Xr + 1; $Xi++) {
                    [Int64]$YPrimed = $YPrimedBase

                    For([Int64]$Yi = $Yr - 1; $Yi -LE $Yr + 1; $Yi++) {
                        [Int64]$ZPrimed = $ZPrimedBase

                        For([Int64]$Zi = $Zr - 1; $Zi -LE $Zr + 1; $Zi++) {
                            [Int64]$AHash        = [FastNoiseLite]::Hash($ASeed, $XPrimed, $YPrimed, $ZPrimed)
                            [Int64]$Idx          = $AHash -BAND (255 -SHL 2)
                            [Single]$VecX        = ([Single]($Xi - $X) + [FastNoiseLite]::RANDVECS3D[$Idx] * $CellularJitter)
                            [Single]$VecY        = ([Single]($Yi - $Y) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 1] * $CellularJitter)
                            [Single]$VecZ        = ([Single]($Zi - $Z) + [FastNoiseLite]::RANDVECS3D[$Idx -BOR 2] * $CellularJitter)
                            [Single]$NewDistance = (
                                [FastNoiseLite]::FastAbs($VecX) +
                                [FastNoiseLite]::FastAbs($VecY) +
                                [FastNoiseLite]::FastAbs($VecZ)
                            ) + (
                                $VecX * $VecX +
                                $VecY * $VecY +
                                $VecZ * $VecZ
                            )

                            $Distance1 = [FastNoiseLite]::FastMax([FastNoiseLite]::FastMin($Distance1, $NewDistance), $Distance0)
                            If($NewDistance -LT $Distance0) {
                                $Distance0   = $NewDistance
                                $ClosestHash = $AHash
                            }

                            $Zprimed += [FastNoiseLite]::PRIMEZ
                        }

                        $YPrimed += [FastNoiseLite]::PRIMEY
                    }

                    $XPrimed += [FastNoiseLite]::PRIMEX
                }

                Break
            }

            Default {
                Break
            }
        }

        If($this.CellularDistanceFunction -EQ [FnlCellularDistanceFunction]::Euclidean -AND $this.CellularReturnType -GE [FnlCellularReturnType]::Distance) {
            $Distance0 = [FastNoiseLite]::FastSqrt($Distance0)

            If($this.CellularReturnType -GE [FnlCellularReturnType].Distance2) {
                $Distance1 = [FastNoiseLite]::FastSqrt($Distance1)
            }
        }

        Switch($this.CellularReturnType) {
            ([FnlCellularReturnType]::CellValue) {
                Return $ClosestHash * (1 / [FastNoiseLite]::HASHCALC_MAGIC)
            }

            ([FnlCellularReturnType]::Distance) {
                Return $Distance0 - 1
            }

            ([FnlCellularReturnType]::Distance2) {
                Return $Distance1 - 1
            }

            ([FnlCellularReturnType]::Distance2Add) {
                Return ($Distance1 + $Distance0) * 0.5 - 1
            }

            ([FnlCellularReturnType]::Distance2Sub) {
                Return $Distance1 - $Distance0 - 1
            }

            ([FnlCellularReturnType]::Distance2Mul) {
                Return $Distance1 * $Distance0 * 0.5 - 1
            }

            ([FnlCellularReturnType]::Distance2Div) {
                Return $Distance0 / $Distance1 - 1
            }

            Default {
                Return 0
            }
        }

        Return 0
    }

    [Single]SinglePerlin(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$X0   = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y0   = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xd0 = ([Single]($X - $X0))
        [Single]$Yd0 = ([Single]($Y - $Y0))
        [Single]$Xd1 = $Xd0 - 1
        [Single]$Yd1 = $Yd0 - 1
        [Single]$Xs  = [FastNoiseLite]::InterpQuintic($Xd0)
        [Single]$Ys  = [FastNoiseLite]::InterpQuintic($Yd0)

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY

        [Int64]$X1 = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1 = $Y0 + [FastNoiseLite]::PRIMEY

        [Single]$Xf0 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord($ASeed, $X0, $Y0, $Xd0, $Yd0),
            [FastNoiseLite]::GradCoord($ASeed, $X1, $Y0, $Xd1, $Yd0),
            $Xs
        )
        [Single]$Xf1 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord($ASeed, $X0, $Y1, $Xd0, $Yd1),
            [FastNoiseLite]::GradCoord($ASeed, $X1, $Y1, $Xd1, $Yd1),
            $Xs
        )

        Return [FastNoiseLite]::Lerp($Xf0, $Xf1, $Ys) * 1.4247691104677813
    }

    [Single]SinglePerlin(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$X0   = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y0   = [FastNoiseLite]::FastFloor($Y)
        [Int64]$Z0   = [FastNoiseLite]::FastFloor($Z)
        [Single]$Xd0 = ([Single]($X - $X0))
        [Single]$Yd0 = ([Single]($Y - $Y0))
        [Single]$Zd0 = ([Single]($Z - $Z0))
        [Single]$Xd1 = $Xd0 - 1
        [Single]$Yd1 = $Yd0 - 1
        [Single]$Zd1 = $Zd0 - 1
        [Single]$Xs  = [FastNoiseLite]::InterpQuintic($Xd0)
        [Single]$Ys  = [FastNoiseLite]::InterpQuintic($Yd0)
        [Single]$Zs  = [FastNoiseLite]::InterpQuintic($Zd0)

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY
        $Z0 *= [FastNoiseLite]::PRIMEZ

        [Int64]$X1 = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1 = $Y0 + [FastNoiseLite]::PRIMEY
        [Int64]$Z1 = $Z0 + [FastNoiseLite]::PRIMEZ

        [Single]$Xf00 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X0, $Y0, $Z0,
                $Xd0, $Yd0, $Zd0
            ),
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X1, $Y0, $Z0,
                $Xd1, $Yd0, $Zd0
            ),
            $Xs
        )
        [Single]$Xf10 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X0, $Y1, $Z0,
                $Xd0, $Yd1, $Zd0
            ),
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X1, $Y1, $Z0,
                $Xd1, $Yd1, $Zd0
            ),
            $Xs
        )
        [Single]$Xf01 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X0, $Y0, $Z1,
                $Xd0, $Yd0, $Zd1
            ),
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X1, $Y0, $Z1,
                $Xd1, $Yd0, $Zd1
            ),
            $Xs
        )
        [Single]$Xf11 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X0, $Y1, $Z1,
                $Xd0, $Yd1, $Zd1
            ),
            [FastNoiseLite]::GradCoord(
                $ASeed,
                $X1, $Y1, $Z1,
                $Xd1, $Yd1, $Zd1
            ),
            $Xs
        )

        [Single]$Yf0 = [FastNoiseLite]::Lerp($Xf00, $Xf10, $Ys)
        [Single]$Yf1 = [FastNoiseLite]::Lerp($Xf01, $Xf11, $Ys)

        Return [FastNoiseLite]::Lerp($Yf0, $Yf1, $Zs) * 0.964921414852142333984375
    }

    [Single]SingleValueCubic(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$X1  = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y1  = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xs = ([Single]($X - $X1))
        [Single]$Ys = ([Single]($Y - $Y1))

        $X1 *= [FastNoiseLite]::PRIMEX
        $Y1 *= [FastNoiseLite]::PRIMEY

        [Int64]$X0 = $X1 - [FastNoiseLite]::PRIMEX
        [Int64]$Y0 = $Y1 - [FastNoiseLite]::PRIMEY
        [Int64]$X2 = $X1 + [FastNoiseLite]::PRIMEX
        [Int64]$Y2 = $Y1 + [FastNoiseLite]::PRIMEY
        
        # THE FOLLOWING TWO STATEMENTS ORIGINALLY USED UNCHECKED STATEMENTS IN THE ARITHMETIC.
        # POWERSHELL DOESN'T REALLY OFFER THIS, SO A FIXED CEILING COMPENSATING CONTROL IS
        # USED (WHICH WOULD LIKELY BE THE SAME RESULT IN C# GIVEN THE BEHAVIOR OF THE UNCHECKED OPERATION,
        # SAVE THE LACK OF A THROWN EXCEPTION).
        #
        # ANOTHER SANITY CHECK HERE IS TO USE INT64 RATHER THAN INT. INT MASKS TO INT32, AND AN OVERFLOW WILL THROW
        # AN EXCEPTION IN POWERSHELL (SYSTEM.OVERFLOWEXCEPTION).
        [Int64]$X3 = $X1 + (([FastNoiseLite]::APRIMEXMULT2 -GT [Int64]::MaxValue) ? [Int64]::MaxValue : [FastNoiseLite]::APRIMEXMULT2)
        [Int64]$Y3 = $Y1 + (([FastNoiseLite]::APRIMEYMULT2 -GT [Int64]::MaxValue) ? [Int64]::MaxValue : [FastNoiseLite]::APRIMEYMULT2)

        Return [FastNoiseLite]::CubicLerp(
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0),
                [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0),
                [FastNoiseLite]::ValCoord($ASeed, $X2, $Y0),
                [FastNoiseLite]::ValCoord($ASeed, $X3, $Y0),
                $Xs
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1),
                [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1),
                [FastNoiseLite]::ValCoord($ASeed, $X2, $Y1),
                [FastNoiseLite]::ValCoord($ASeed, $X3, $Y1),
                $Xs
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::ValCoord($ASeed, $X0, $Y2),
                [FastNoiseLite]::ValCoord($ASeed, $X1, $Y2),
                [FastNoiseLite]::ValCoord($ASeed, $X2, $Y2),
                [FastNoiseLite]::ValCoord($ASeed, $X3, $Y2),
                $Xs
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::ValCoord($ASeed, $X0, $Y3),
                [FastNoiseLite]::ValCoord($ASeed, $X1, $Y3),
                [FastNoiseLite]::ValCoord($ASeed, $X2, $Y3),
                [FastNoiseLite]::ValCoord($ASeed, $X3, $Y3),
                $Xs
            ),
            $Ys
        ) * (1 / (1.5 * 1.5))
    }

    [Single]SingleValueCubic(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$X1  = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y1  = [FastNoiseLite]::FastFloor($Y)
        [Int64]$Z1  = [FastNoiseLite]::FastFloor($Z)
        [Single]$Xs = ([Single]($X - $X1))
        [Single]$Ys = ([Single]($Y - $Y1))
        [Single]$Zs = ([Single]($Z - $Z1))

        $X1 *= [FastNoiseLite]::PRIMEX
        $Y1 *= [FastNoiseLite]::PRIMEY
        $Z1 *= [FastNoiseLite]::PRIMEZ

        [Int64]$X0 = $X1 - [FastNoiseLite]::PRIMEX
        [Int64]$Y0 = $Y1 - [FastNoiseLite]::PRIMEY
        [Int64]$Z0 = $Z1 - [FastNoiseLite]::PRIMEZ
        [Int64]$X2 = $X1 + [FastNoiseLite]::PRIMEX
        [Int64]$Y2 = $Y1 + [FastNoiseLite]::PRIMEY
        [Int64]$Z2 = $Z1 + [FastNoiseLite]::PRIMEZ

        # THE FOLLOWING THREE STATEMENTS ORIGINALLY USED UNCHECKED STATEMENTS IN THE ARITHMETIC.
        # POWERSHELL DOESN'T REALLY OFFER THIS, SO A FIXED CEILING COMPENSATING CONTROL IS
        # USED (WHICH WOULD LIKELY BE THE SAME RESULT IN C# GIVEN THE BEHAVIOR OF THE UNCHECKED OPERATION,
        # SAVE THE LACK OF A THROWN EXCEPTION).
        #
        # ANOTHER SANITY CHECK HERE IS TO USE INT64 RATHER THAN INT. INT MASKS TO INT32, AND AN OVERFLOW WILL THROW
        # AN EXCEPTION IN POWERSHELL (SYSTEM.OVERFLOWEXCEPTION).
        [Int64]$X3 = $X1 + (([FastNoiseLite]::APRIMEXMULT2 -GT [Int64]::MaxValue) ? [Int64]::MaxValue : [FastNoiseLite]::APRIMEXMULT2)
        [Int64]$Y3 = $Y1 + (([FastNoiseLite]::APRIMEYMULT2 -GT [Int64]::MaxValue) ? [Int64]::MaxValue : [FastNoiseLite]::APRIMEYMULT2)
        [Int64]$Z3 = $Z1 + (([FastNoiseLite]::APRIMEZMULT2 -GT [Int64]::MaxValue) ? [Int64]::MaxValue : [FastNoiseLite]::APRIMEZMULT2)

        Return [FastNoiseLite]::CubicLerp(
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y0, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y0, $Z0),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y1, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y1, $Z0),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y2, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y2, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y2, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y2, $Z0),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y3, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y3, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y3, $Z0),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y3, $Z0),
                    $Xs
                ),
                $Ys
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y0, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y0, $Z1),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y1, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y1, $Z1),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y2, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y2, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y2, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y2, $Z1),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y3, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y3, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y3, $Z1),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y3, $Z1),
                    $Xs
                ),
                $Ys
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y0, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y0, $Z2),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y1, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y1, $Z2),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y2, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y2, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y2, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y2, $Z2),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y3, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y3, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y3, $Z2),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y3, $Z2),
                    $Xs
                ),
                $Ys
            ),
            [FastNoiseLite]::CubicLerp(
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y0, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y0, $Z3),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y1, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y1, $Z3),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y2, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y2, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y2, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y2, $Z3),
                    $Xs
                ),
                [FastNoiseLite]::CubicLerp(
                    [FastNoiseLite]::ValCoord($ASeed, $X0, $Y3, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X1, $Y3, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X2, $Y3, $Z3),
                    [FastNoiseLite]::ValCoord($ASeed, $X3, $Y3, $Z3),
                    $Xs
                ),
                $Ys
            ),
            $Zs
        ) * (1 / (1.5 * 1.5 * 1.5))
    }

    [Single]SingleValue(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y
    ) {
        [Int64]$X0  = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y0  = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xs = [FastNoiseLite]::InterpHermite(([Single]($X - $X0)))
        [Single]$Ys = [FastNoiseLite]::InterpHermite(([Single]($Y - $Y0)))

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY

        [Int64]$X1 = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1 = $Y0 + [FastNoiseLite]::PRIMEY

        [Single]$Xf0 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0),
            $Xs
        )
        [Single]$Xf1 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1),
            $Xs
        )

        Return [FastNoiseLite]::Lerp($Xf0, $Xf1, $Ys)
    }

    [Single]SingleValue(
        [Int64]$ASeed,
        [Single]$X,
        [Single]$Y,
        [Single]$Z
    ) {
        [Int64]$X0  = [FastNoiseLite]::FastFloor($X)
        [Int64]$Y0  = [FastNoiseLite]::FastFloor($Y)
        [Int64]$Z0  = [FastNoiseLite]::FastFloor($Z)
        [Single]$Xs = [FastNoiseLite]::InterpHermite(([Single]($X - $X0)))
        [Single]$Ys = [FastNoiseLite]::InterpHermite(([Single]($Y - $Y0)))
        [Single]$Zs = [FastNoiseLite]::InterpHermite(([Single]($Z - $Z0)))

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY
        $Z0 *= [FastNoiseLite]::PRIMEZ

        [Int64]$X1 = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1 = $Y0 + [FastNoiseLite]::PRIMEY
        [Int64]$Z1 = $Z0 + [FastNoiseLite]::PRIMEZ

        [Single]$Xf00 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z0),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z0),
            $Xs
        )
        [Single]$Xf10 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z0),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z0),
            $Xs
        )
        [Single]$Xf01 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y0, $Z1),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y0, $Z1),
            $Xs
        )
        [Single]$Xf11 = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::ValCoord($ASeed, $X0, $Y1, $Z1),
            [FastNoiseLite]::ValCoord($ASeed, $X1, $Y1, $Z1),
            $Xs
        )

        [Single]$Yf0 = [FastNoiseLite]::Lerp($Xf00, $Xf10, $Ys)
        [Single]$Yf1 = [FastNoiseLite]::Lerp($Xf01, $Xf11, $Ys)

        Return [FastNoiseLite]::Lerp($Yf0, $Yf1, $Zs)
    }

    [Void]DoSingleDomainWarp(
        [Int64]$ASeed,
        [Single]$Amp,
        [Single]$Freq,
        [Single]$X,
        [Single]$Y,
        [Ref]$Xr,
        [Ref]$Yr

    ) {
        Switch($this.DomainWarpType) {
            ([FnlDomainWarpType]::OpenSimplex2) {
                $this.SingleDomainWarpOpenSimplex2Gradient($ASeed, $Amp * [FastNoiseLite]::SIMPLEXVALMODA_MAGIC, $Freq, $X, $Y, $Xr, $Yr, $false)

                Break
            }

            ([FnlDomainWarpType]::OpenSimplex2Reduced) {
                $this.SingleDomainWarpSimplexGradient($ASeed, $Amp * 16.0, $Freq, $X, $Y, $Xr, $Yr, $true)

                Break
            }

            ([FnlDomainWarpType]::BasicGrid) {
                $this.SingleDomainWarpBasicGrid($ASeed, $Amp, $Freq, $X, $Y, $Xr, $Yr)

                Break
            }

            Default {
                Break
            }
        }
    }

    [Void]DoSingleDomainWarp(
        [Int64]$ASeed,
        [Single]$Amp,
        [Single]$Freq,
        [Single]$X,
        [Single]$Y,
        [Single]$Z,
        [Ref]$Xr,
        [Ref]$Yr,
        [Ref]$Zr
    ) {
        Switch($this.DomainWarpType) {
            ([FnlDomainWarpType]::OpenSimplex2) {
                $this.SingleDomainWarpOpenSimplex2Gradient($ASeed, $Amp * [FastNoiseLite]::SIMPLEXVALMODA_MAGIC, $Freq, $X, $Y, $Z, $Xr, $Yr, $Zr, $false)

                Break
            }

            ([FnlDomainWarpType]::OpenSimplex2Reduced) {
                $this.SingleDomainWarpOpenSimplex2Gradient($ASeed, $Amp * 7.71604938271605, $Freq, $X, $Y, $Z, $Xr, $Yr, $Zr, $true)

                Break
            }

            ([FnlDomainWarpType]::BasicGrid) {
                $this.SingleDomainWarpBasicGrid($ASeed, $Amp, $Freq, $X, $Y, $Z, $Xr, $Yr, $Zr)

                Break
            }

            Default {
                Break
            }
        }
    }

    [Void]DomainWarpSingle(
        [Ref]$X,
        [Ref]$Y
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency
        [Single]$Xs   = $X.Value
        [Single]$Ys   = $Y.Value

        $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys))
        $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $X, $Y)
    }

    [Void]DomainWarpSingle(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency
        [Single]$Xs   = $X.Value
        [Single]$Ys   = $Y.Value
        [Single]$Zs   = $Z.Value

        $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys), ([Ref]$Zs))
        $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $Zs, $X, $Y, $Z)
    }

    [Void]DomainWarpFractalProgressive(
        [Ref]$X,
        [Ref]$Y
    ) {
        [Int64]$Aseed = $this.Seed
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Xs = $X.Value
            [Single]$Ys = $Y.Value

            $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys))
            $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $X, $Y)

            $ASeed++
            $Amp  *= $this.Gain
            $Freq *= $this.Lacunarity
        }
    }

    [Void]DomainWarpFractalProgressive(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            [Single]$Xs = $X.Value
            [Single]$Ys = $Y.Value
            [Single]$Zs = $Z.Value

            $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys), ([Ref]$Zs))
            $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $Zs, $X, $Y, $Z)

            $ASeed++
            $Amp  *= $this.Gain
            $Freq *= $this.Lacunarity
        }
    }

    [Void]DomainWarpFractalIndependent(
        [Ref]$X,
        [Ref]$Y
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Xs   = $X.Value
        [Single]$Ys   = $Y.Value
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency

        $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys))

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $X, $Y)

            $ASeed++
            $Amp  *= $this.Gain
            $Freq *= $this.Lacunarity
        }
    }

    [Void]DomainWarpFractalIndependent(
        [Ref]$X,
        [Ref]$Y,
        [Ref]$Z
    ) {
        [Int64]$ASeed = $this.Seed
        [Single]$Xs   = $X.Value
        [Single]$Ys   = $Y.Value
        [Single]$Zs   = $Z.Value
        [Single]$Amp  = $this.DomainWarpAmp * $this.FractalBounding
        [Single]$Freq = $this.Frequency

        $this.TransformDomainWarpCoordinate(([Ref]$Xs), ([Ref]$Ys), ([Ref]$Zs))

        For([Int64]$I = 0; $I -LT $this.Octaves; $I++) {
            $this.DoSingleDomainWarp($ASeed, $Amp, $Freq, $Xs, $Ys, $Zs, $X, $Y, $Z)

            $ASeed++
            $Amp  *= $this.Gain
            $Freq *= $this.Lacunarity
        }
    }

    [Void]SingleDomainWarpBasicGrid(
        [Int64]$ASeed,
        [Single]$WarpAmp,
        [Single]$AFrequency,
        [Single]$X,
        [Single]$Y,
        [Ref]$Xr,
        [Ref]$Yr
    ) {
        [Single]$Xf = $X * $AFrequency
        [Single]$Yf = $Y * $AFrequency
        [Int64]$X0  = [FastNoiseLite]::FastFloor($Xf)
        [Int64]$Y0  = [FastNoiseLite]::FastFloor($Yf)
        [Single]$Xs = [FastNoiseLite]::InterpHermite(([Single]($Xf - $X0)))
        [Single]$Ys = [FastNoiseLite]::InterpHermite(([Single]($Yf - $Y0)))

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY

        [Int64]$X1    = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1    = $Y0 + [FastNoiseLite]::PRIMEY
        [Int64]$Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y0) -BAND (255 -SHL 1)
        [Int64]$Hash1 = [FastNoiseLite]::Hash($ASeed, $X1, $Y1) -BAND (255 -SHL 1)

        [Single]$Lx0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS2D[$Hash0],
            [FastNoiseLite]::RANDVECS2D[$Hash1],
            $Xs
        )
        [Single]$Ly0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS2D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS2D[$Hash1 -BOR 1],
            $Xs
        )

        $Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y1) -BAND (255 -SHL 1)
        $Hash1 = [FastNoiseLite]::Hash($Aseed, $X1, $Y1) -BAND (255 -SHL 1)

        [Single]$Lx1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS2D[$Hash0],
            [FastNoiseLite]::RANDVECS2D[$Hash1],
            $Xs
        )
        [Single]$Ly1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS2D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS2D[$Hash1 -BOR 1],
            $Xs
        )

        $Xr.Value += [FastNoiseLite]::Lerp($Lx0x, $Lx1x, $Ys) * $WarpAmp
        $Yr.Value += [FastNoiseLite]::Lerp($Ly0x, $Ly1x, $Ys) * $WarpAmp
    }

    [Void]SingleDomainWarpBasicGrid(
        [Int64]$ASeed,
        [Single]$WarpAmp,
        [Single]$AFrequency,
        [Single]$X,
        [Single]$Y,
        [Single]$Z,
        [Ref]$Xr,
        [Ref]$Yr,
        [Ref]$Zr
    ) {
        [Single]$Xf = $X * $AFrequency
        [Single]$Yf = $Y * $AFrequency
        [Single]$Zf = $Z * $AFrequency
        [Int64]$X0  = [FastNoiseLite]::FastFloor($Xf)
        [Int64]$Y0  = [FastNoiseLite]::FastFloor($Yf)
        [Int64]$Z0  = [FastNoiseLite]::FastFloor($Zf)
        [Single]$Xs = [FastNoiseLite]::InterpHermite(([Single]($Xf - $X0)))
        [Single]$Ys = [FastNoiseLite]::InterpHermite(([Single]($Yf - $Y0)))
        [Single]$Zs = [FastNoiseLite]::InterpHermite(([Single]($Zf - $Z0)))

        $X0 *= [FastNoiseLite]::PRIMEX
        $Y0 *= [FastNoiseLite]::PRIMEY
        $Z0 *= [FastNoiseLite]::PRIMEZ

        [Int64]$X1    = $X0 + [FastNoiseLite]::PRIMEX
        [Int64]$Y1    = $Y0 + [FastNoiseLite]::PRIMEY
        [Int64]$Z1    = $Z0 + [FastNoiseLite]::PRIMEZ
        [Int64]$Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y0, $Z0) -BAND (255 -SHL 2)
        [Int64]$Hash1 = [FastNoiseLite]::Hash($ASeed, $X1, $Y0, $Z0) -BAND (255 -SHL 2)

        [Single]$Lx0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0],
            [FastNoiseLite]::RANDVECS3D[$Hash1],
            $Xs
        )
        [Single]$Ly0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 1],
            $Xs
        )
        [Single]$Lz0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 2],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 2],
            $Xs
        )

        $Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y1, $Z0) -BAND (255 -SHL 2)
        $Hash1 = [FastNoiseLite]::Hash($Aseed, $X1, $Y1, $Z0) -BAND (255 -SHL 2)

        [Single]$Lx1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0],
            [FastNoiseLite]::RANDVECS3D[$Hash1],
            $Xs
        )
        [Single]$Ly1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 1],
            $Xs
        )
        [Single]$Lz1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 2],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 2],
            $Xs
        )

        [Single]$Lx0y = [FastNoiseLite]::Lerp($Lx0x, $Lx1x, $Ys)
        [Single]$Ly0y = [FastNoiseLite]::Lerp($Ly0x, $Ly1x, $Ys)
        [Single]$Lz0y = [FastNoiseLite]::Lerp($Lz0x, $Lz1x, $Ys)

        $Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y0, $Z1) -BAND (255 -SHL 2)
        $Hash1 = [FastNoiseLite]::Hash($ASeed, $X1, $Y0, $Z1) -BAND (255 -SHL 2)

        $Lx0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0],
            [FastNoiseLite]::RANDVECS3D[$Hash1],
            $Xs
        )
        $Ly0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 1],
            $Xs
        )
        $Lz0x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 2],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 2],
            $Xs
        )

        $Hash0 = [FastNoiseLite]::Hash($ASeed, $X0, $Y1, $Z1) -BAND (255 -SHL 2)
        $Hash1 = [FastNoiseLite]::Hash($ASeed, $X1, $Y1, $Z1) -BAND (255 -SHL 2)

        $Lx1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0],
            [FastNoiseLite]::RANDVECS3D[$Hash1],
            $Xs
        )
        $Ly1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 1],
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 1],
            $Xs
        )
        $Lz1x = [FastNoiseLite]::Lerp(
            [FastNoiseLite]::RANDVECS3D[$Hash0 -BOR 2],
            [FastNoiseLite]::RANDVECS3D[$Hash1 -BOR 2],
            $Xs
        )

        $Xr.Value += [FastNoiseLite]::Lerp(
            $Lx0y,
            [FastNoiseLite]::Lerp(
                $Lx0x,
                $Lx1x,
                $Ys
            ),
            $Zs
        ) * $WarpAmp
        $Yr.Value += [FastNoiseLite]::Lerp(
            $Ly0y,
            [FastNoiseLite]::Lerp(
                $Ly0x,
                $Ly1x,
                $Ys
            ),
            $Zs
        ) * $WarpAmp
        $Zr.Value += [FastNoiseLite]::Lerp(
            $Lz0y,
            [FastNoiseLite]::Lerp(
                $Ly0x,
                $Lz1x,
                $Ys
            ),
            $Zs
        ) * $WarpAmp
    }

    [Void]SingleDomainWarpSimplexGradient(
        [Int64]$ASeed,
        [Single]$WarpAmp,
        [Single]$AFrequency,
        [Single]$X,
        [Single]$Y,
        [Ref]$Xr,
        [Ref]$Yr,
        [Boolean]$OutGradOnly
    ) {
        [Single]$G2   = (3 - [FastNoiseLite]::SQRT3) / 6
        [Single]$G2m1 = $G2 - 1
        [Single]$G2a1 = 1 - 2 * $G2

        $X *= $AFrequency
        $Y *= $AFrequency

        [Int64]$I   = [FastNoiseLite]::FastFloor($X)
        [Int64]$J   = [FastNoiseLite]::FastFloor($Y)
        [Single]$Xi = ([Single]($X - $I))
        [Single]$Yi = ([Single]($Y - $J))
        [Single]$T  = ($Xi + $Yi) * $G2
        [Single]$X0 = $Xi - $T
        [Single]$Y0 = $Yi - $T

        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY

        [Single]$Vx = 0
        [Single]$Vy = 0
        [Single]$A  = 0.5 - $X0 * $X0 - $Y0 * $Y0
        [Single]$A2 = $A * $A

        If($A -GT 0) {
            [Single]$Aaaa = $A2 * $A2
            [Single]$Xo   = 0
            [Single]$Yo   = 0

            If($OutGradOnly -EQ $true) {
                [FastNoiseLite]::GradCoordOut($ASeed, $I, $J, ([Ref]$Xo), ([Ref]$Yo))
            } Else {
                [FastNoiseLite]::GradCoordDual($ASeed, $I, $J, $X0, $Y0, ([Ref]$Xo), ([Ref]$Yo))
            }
            $Vx += $Aaaa * $Xo
            $Vy += $Aaaa * $Yo
        }

        [Single]$C = ([Single](
            2 * $G2a1 * (1 / $G2 - 2)) * $T +
            ([Single](-2 * $G2a1 * $G2a1) + $A)
        )
        [Single]$C2 = $C * $C

        If($C -GT 0) {
            [Single]$X2   = $X0 + (2 * $G2m1)
            [Single]$Y2   = $Y0 + (2 * $G2m1)
            [Single]$Cccc = $C2 * $C2
            [Single]$Xo   = 0
            [Single]$Yo   = 0

            If($OutGradOnly -EQ $true) {
                [FastNoiseLite]::GradCoordOut($ASeed, $I + [FastNoiseLite]::PRIMEX, $J + [FastNoiseLite]::PRIMEY, ([Ref]$Xo), ([Ref]$Yo))
            } Else {
                [FastNoiseLite]::GradCoordDual($ASeed, $I + [FastNoiseLite]::PRIMEX, $J + [FastNoiseLite]::PRIMEY, $X2, $Y2, ([Ref]$Xo), ([Ref]$Yo))
            }

            $Vx += $Cccc * $Xo
            $Vy += $Cccc * $Yo
        }

        If($Y0 -GT $X0) {
            [Single]$X1 = $X0 + $G2
            [Single]$Y1 = $Y0 + $G2m1
            [Single]$B  = 0.5 - $X1 * $X1 - $Y1 * $Y1
            [Single]$B2 = $B * $B

            If($B -GT 0) {
                [Single]$Bbbb = $B2 * $B2
                [Single]$Xo   = 0
                [Single]$Yo   = 0

                If($OutGradOnly -EQ $true) {
                    [FastNoiseLite]::GradCoordOut($ASeed, $I, $J + [FastNoiseLite]::PRIMEY, ([Ref]$Xo), ([Ref]$Yo))
                } Else {
                    [FastNoiseLite]::GradCoordDual($ASeed, $I, $J + [FastNoiseLite]::PRIMEY, $X1, $Y1, ([Ref]$Xo), ([Ref]$Yo))
                }

                $Vx += $Bbbb * $Xo
                $Vy += $Bbbb * $Yo
            }
        } Else {
            [Single]$X1 = $X0 + $G2m1
            [Single]$Y1 = $Y0 + $G2
            [Single]$B  = 0.5 - $X1 * $X1 - $Y1 * $Y1
            [Single]$B2 = $B * $B

            If($B -GT 0) {
                [Single]$Bbbb = $B2 * $B2
                [Single]$Xo   = 0
                [Single]$Yo   = 0

                If($OutGradOnly -EQ $true) {
                    [FastNoiseLite]::GradCoordOut($ASeed, $I + [FastNoiseLite]::PRIMEX, $J, ([Ref]$Xo), ([Ref]$Yo))
                } Else {
                    [FastNoiseLite]::GradCoordDual($ASeed, $I + [FastNoiseLite]::PRIMEX, $J, $X1, $Y1, ([Ref]$Xo), ([Ref]$Yo))
                }

                $Vx += $Bbbb * $Xo
                $Vy += $Bbbb * $Yo
            }
        }

        $Xr.Value += $Vx * $WarpAmp
        $Yr.Value += $Vy * $WarpAmp
    }

    [Void]SingleDomainWarpOpenSimplex2Gradient(
        [Int64]$ASeed,
        [Single]$WarpAmp,
        [Single]$AFrequency,
        [Single]$X,
        [Single]$Y,
        [Single]$Z,
        [Ref]$Xr,
        [Ref]$Yr,
        [Ref]$Zr,
        [Boolean]$OutGradOnly
    ) {
        $X *= $AFrequency
        $Y *= $AFrequency
        $Z *= $AFrequency

        [Int64]$I      = [FastNoiseLite]::FastRound($X)
        [Int64]$J      = [FastNoiseLite]::FastRound($Y)
        [Int64]$K      = [FastNoiseLite]::FastRound($Z)
        [Single]$X0    = ([Single]($X - $I))
        [Single]$Y0    = ([Single]($Y - $J))
        [Single]$Z0    = ([Single]($Z - $K))
        [Int64]$XNSign = ([Int64](-$X0 - 1) -BOR 1)
        [Int64]$YNSign = ([Int64](-$Y0 - 1) -BOR 1)
        [Int64]$ZNSign = ([Int64](-$Z0 - 1) -BOR 1)
        [Single]$Ax0   = $XNSign * -$X0
        [Single]$Ay0   = $YNSign * -$Y0
        [Single]$Az0   = $ZNSign * -$Z0

        $I *= [FastNoiseLite]::PRIMEX
        $J *= [FastNoiseLite]::PRIMEY
        $K *= [FastNoiseLite]::PRIMEZ

        [Single]$Vx = 0
        [Single]$Vy = 0
        [Single]$Vz = 0
        [Single]$A  = (0.6 - $X0 * $X0)- ($Y0 * $Y0 + $Z0 * $Z0)
        [Single]$A2 = $A * $A

        For([Int64]$L = 0; ; $L++) {
            If($A -GT 0) {
                [Single]$Aaaa = $A2 * $A2
                [Single]$Xo   = 0
                [Single]$Yo   = 0
                [Single]$Zo   = 0

                If($OutGradOnly -EQ $true) {
                    [FastNoiseLite]::GradCoordOut($ASeed, $I, $J, $K, ([Ref]$Xo), ([Ref]$Yo), ([Ref]$Zo))
                } Else {
                    [FastNoiseLite]::GradCoordDual($ASeed, $I, $J, $K, $X0, $Y0, $Z0, ([Ref]$Xo), ([Ref]$Yo), ([Ref]$Zo))
                }

                $Vx += $Aaaa * $Xo
                $Vy += $Aaaa * $Yo
                $Vz += $Aaaa * $Zo
            }

            [Int64]$I1  = $I
            [Int64]$J1  = $J
            [Int64]$K1  = $K
            [Single]$B  = $A
            [Single]$B2 = $B * $B
            [Single]$X1 = $X0
            [Single]$Y1 = $Y0
            [Single]$Z1 = $Z0

            If($Ax0 -GE $Ay0 -AND $Ax0 -GE $Az0) {
                $X1 += $XNSign
                $B  += $Ax0 + $Ax0
                $I1 -= $XNSign + [FastNoiseLite]::PRIMEX
            } Elseif($Ay0 -GT $Ax0 -AND $Ay0 -GE $Az0) {
                $Y1 += $YNSign
                $B  += $Ay0 + $Ay0
                $J1 -= $YNSign * [FastNoiseLite]::PRIMEY
            } Else {
                $Z1 += $ZNSign
                $B  += $Az0 + $Az0
                $K1 -= $ZNSign * [FastNoiseLite]::PRIMEZ
            }

            If($B -GT 1) {
                $B -= 1

                [Single]$Bbbb = $B2 * $B2
                [Single]$Xo   = 0
                [Single]$Yo   = 0
                [Single]$Zo   = 0

                If($OutGradOnly -EQ $true) {
                    [FastNoiseLite]::GradCoordOut($ASeed, $I, $J, $K, ([Ref]$Xo), ([Ref]$Yo), ([Ref]$Zo))
                } Else {
                    [FastNoiseLite]::GradCoordDual($ASeed, $I1, $J1, $K1, $X1, $Y1, $Z1, ([Ref]$Xo), ([Ref]$Yo), ([Ref]$Zo))
                }

                $Vx += $Bbbb * $Xo
                $Vy += $Bbbb * $Yo
                $Vz += $Bbbb * $Zo
            }

            If($L -EQ 1) {
                Break
            }

            $Ax0     = 0.5 - $Ax0
            $Ay0     = 0.5 - $Ay0
            $Az0     = 0.5 - $Az0
            $X0      = $XNSign * $Ax0
            $Y0      = $YNSign * $Ay0
            $Z0      = $ZNSign * $Az0
            $A      += (0.75 - $Ax0) - ($Ay0 + $Az0)
            $I      += ($XNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEX
            $J      += ($YNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEY
            $K      += ($ZNSign -SHR 1) -BAND [FastNoiseLite]::PRIMEZ
            $XNSign  = -$XNSign
            $YNSign  = -$YNSign
            $ZNSign  = -$ZNSign
            $ASeed  += [FastNoiseLite]::SEEDADD_MAGIC
        }

        $Xr.Value += $Vx * $WarpAmp
        $Yr.Value += $Vy * $WarpAmp
        $Zr.Value += $Vz * $WarpAmp
    }
}
